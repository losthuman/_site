<!DOCTYPE html> <html lang="ru"><head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta property="og:image" content="/assets/images/2018-09-22-formatirovanie-strok-v-python/top_image.jpg" /><!-- Begin Jekyll SEO tag v2.6.1 --> <title>Клонирование объектов в python | Losthuman</title> <meta name="generator" content="Jekyll v3.8.5" /> <meta property="og:title" content="Клонирование объектов в python" /> <meta property="og:locale" content="ru" /> <meta name="description" content="Операторы присваивания в Python не создают копии объектов, они связывают имена только с объектом. Для неизменяемых объектов это обычно не имеет значения. Но для работы с изменяемыми объектами или наборами изменяемых объектов вы можете искать способ создания «реальных копий» или «клонов» этих объектов." /> <meta property="og:description" content="Операторы присваивания в Python не создают копии объектов, они связывают имена только с объектом. Для неизменяемых объектов это обычно не имеет значения. Но для работы с изменяемыми объектами или наборами изменяемых объектов вы можете искать способ создания «реальных копий» или «клонов» этих объектов." /> <link rel="canonical" href="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" /> <meta property="og:url" content="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" /> <meta property="og:site_name" content="Losthuman" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2018-09-23T00:00:00+05:00" /> <script type="application/ld+json"> {"datePublished":"2018-09-23T00:00:00+05:00","headline":"Клонирование объектов в python","mainEntityOfPage":{"@type":"WebPage","@id":"https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html"},"url":"https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html","description":"Операторы присваивания в Python не создают копии объектов, они связывают имена только с объектом. Для неизменяемых объектов это обычно не имеет значения. Но для работы с изменяемыми объектами или наборами изменяемых объектов вы можете искать способ создания «реальных копий» или «клонов» этих объектов.","@type":"BlogPosting","dateModified":"2018-09-23T00:00:00+05:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> <link rel="stylesheet" href="/assets/likely.css"> <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://losthuman.ru/feed.xml" title="Losthuman" /><!-- Put this script tag to the <head> of your page --> <script type="text/javascript" src="https://vk.com/js/api/openapi.js?160"></script><script> if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) { (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-116379514-1', 'auto'); ga('send', 'pageview'); } </script> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116379514-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-116379514-1', { 'optimize_id': 'GTM-NJS47RQ'}); </script> </head> <body><header class="site-header" role="banner"> <div class="wrapper"> <a class="site-title" rel="author" href="/">Losthuman</a> <nav class="site-nav site-nav-custom"> <input type="checkbox" id="nav-trigger" class="nav-trigger" /> <label for="nav-trigger"> <span class="menu-icon"> <svg viewBox="0 0 18 15" width="18px" height="15px"> <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/> </svg> </span> </label> <div class="trigger"> <a class="page-link" href="/about/">О проекте</a> <a class="page-link" href="/categories/technews/index.html">Technews</a> <a class="page-link" href="/categories/code/index.html">Code</a> <a class="page-link" href="/categories/library/index.html">Library</a> </div> </nav> </div> </header> <main class="page-content" aria-label="Content"> <div class="wrapper"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-fg+4w-s-a4+kz" data-ad-client="ca-pub-5706627784425194" data-ad-slot="4102621418"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <div class="container-fluid"> <div class="row"> <div class="col-md-8"> <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title p-name" itemprop="name headline">Клонирование объектов в python</h1> <p class="post-meta"> <time class="dt-published" datetime="2018-09-23T00:00:00+05:00" itemprop="datePublished">Sep 23, 2018 </time></p> </header> <div class="post"> <div class="post-image"> <img src="/assets/images/2018-09-22-formatirovanie-strok-v-python/top_image.jpg" alt="Картинка" > </div> </div> <div class="post-content e-content" itemprop="articleBody"> <p>Операторы присваивания в Python не создают копии объектов, они связывают имена только с объектом. Для неизменяемых объектов это обычно не имеет значения. Но для работы с изменяемыми объектами или наборами изменяемых объектов вы можете искать способ создания «реальных копий» или «клонов» этих объектов.</p> <p>По сути, вам иногда нужны копии, которые вы можете изменить без одновременной автоматической модификации оригинала. В этой главе поговорим о том, как копировать или «клонировать» объекты в Python и обсудим некоторые из связанных с этим предостережений.</p> <p>Давайте начнем с рассмотрения того, как копировать встроенные коллекции в python. Встроенные изменяемые коллекции python, такие как списки (list), словари (dict) и наборы (set), могут быть скопированы путем вызова функций создания соответствующего объекта, которой в качестве аргумента передается существующая коллекция:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new_list = list (original_list) 
new_dict = dict (original_dict) 
new_set = set (original_set)
</code></pre></div></div> <p>Однако этот метод не будет работать для пользовательских объектов, и, кроме того, он создает только поверхностные копии. Для сложных объектов, таких как списки, словари и наборы, существует важное различие между поверхностным (<em>shallow copy</em>) и глубоким (<em>deep copy</em>) копированием:</p> <p>Поверхностная копия означает создание нового объекта коллекции, а затем заполнение его <strong>ссылками</strong> на дочерние объекты, найденные в оригинале. По сути, поверхнгстная копия имеет только один уровень глубины. Процесс копирования не перезаписывается и, следовательно, не будет создавать копии самих дочерних объектов (элементов коллекции).</p> <p>Глубокая копия делает процесс копирования рекурсивным. Это означает сначала создание нового объекта коллекции, а затем рекурсивное заполнение его копиями дочерних объектов, найденных в оригинале. Копирование объектов таким образом просматривает все дерево объектов, чтобы создать полностью независимый клон исходного объекта и всех его дочерних элементов.</p> <p>Не очень понятно на первый взгляд. Итак, давайте рассмотрим некоторые примеры, чтобы усвоить эту разницу между глубокими и поверхностными копиями.</p> <h4 id="создание-поверхносной-неглубокой-копии-объекта">Создание поверхносной (неглубокой) копии объекта</h4> <p>В приведенном ниже примере мы создадим новый вложенный список и затем поверхностно скопируем его с помощью функции list ():</p> »&gt; xs = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] »&gt; ys = list (xs) # Создаем поверхностную копию <p>Это означает, что <code class="highlighter-rouge">ys</code> теперь будет новым и независимым объектом с тем же содержимым, что и <code class="highlighter-rouge">xs</code>. Вы можете проверить это, проверив оба объекта:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; xs
[[1, 2, 3], [4, 5, 6], [7, 8, 9]] 
&gt;&gt;&gt; ys
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre></div></div> <p>Чтобы подтвердить, что <code class="highlighter-rouge">ys</code> действительно независим от оригинала, давайте проведем небольшой эксперимент. Вы можете попробовать добавить новый элемент оригиналу (xs), а затем проверить, повлияла ли эта модификация на копию (ys):   »&gt; xs.append ([10, 11, 12]) »&gt; xs [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] »&gt; ys [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</p> <p>Как вы можете видеть, в данном случае мы получили то, что ожидали. Изменение скопированного списка на поверхностном уровне не было проблемой вообще.</p> <p>Однако, поскольку мы создали только поверхностную копию исходного списка, <code class="highlighter-rouge">ys</code> все еще содержит ссылки на исходные дочерние объекты (дементы спсика), хранящиеся в <code class="highlighter-rouge">xs</code>.</p> <p>Эти элементы не были скопированы. В скопированном списке они были снова указаны как ссылки на оригинылы. Поэтому, когда вы изменяете один из дочерних объектов в <code class="highlighter-rouge">xs</code>, эта модификация будет отражена и в <code class="highlighter-rouge">ys</code>, потому что оба списка имеют одни и те же дочерние объекты:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; xs [1] [0] = 'X'
&gt;&gt;&gt; xs
[[1, 2, 3], ['X', 5, 6], [7, 8, 9], [10, 11, 12]] 
&gt;&gt;&gt; ys
[[1, 2, 3], ['X', 5, 6], [7, 8, 9]]
</code></pre></div></div> <p>В приведенном выше примере мы изменили только <code class="highlighter-rouge">xs</code>. Но оказалось, что оба элемента в списках под индексом 1 в <code class="highlighter-rouge">xs</code> и <code class="highlighter-rouge">ys</code> были изменены. Опять же, это произошло потому, что мы создали только поверхностную копию исходного списка.</p> <p>Если бы мы создали глубокую копию <code class="highlighter-rouge">xs </code>на первом шаге, оба объекта были бы полностью независимыми. Это практическая разница между поверхностной и глубокой копиями объектов.</p> <p>Теперь вы знаете, как создавать поверхностные копии нколлекций, и вы знаете разницу между поверхностным и глубоким копированием. На остались вопросы, на которые следует получить ответы:</p> <p>• Каким образом создаются глубокие копии коллекций?</p> <p>• Как вы можете создавать копии (поверхностные и глубокие) произвольных объектов, включая пользовательские классы?</p> <p>Ответ на эти вопросы лежит в модуле копирования в стандартной библиотеке python. Этот модуль обеспечивает простой интерфейс для создания поверхностных и глубоких копий объектов python.</p> <h4 id="создание-глубоких-копий">Создание глубоких копий</h4> <p>Повторим предыдущий пример копирования списка, но с одной важной разницей. На этот раз мы создадим глубокую копию, используя функцию <code class="highlighter-rouge">deepcopy()</code>, определенную в модуле копирования:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; xs = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 
&gt;&gt;&gt; zs = copy.deepcopy(xs)
</code></pre></div></div> <p>Если проверить <code class="highlighter-rouge">xs</code> и его клон <code class="highlighter-rouge">zs</code>, которые мы создали с помощью <code class="highlighter-rouge">copy.deepcopy()</code>, вы увидите, что они оба выглядят одинаково, как в предыдущем примере:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; xs
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; zs
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre></div></div> <p>Однако, если вы внесете изменения в один из дочерних объектов исходного объекта (<code class="highlighter-rouge">xs</code>), вы увидите, что эта модификация не повлияет на глубину <code class="highlighter-rouge">zs</code>. Оба объекта, оригинал и копия, на этот раз полностью независимы. <code class="highlighter-rouge">xs</code> был клонирован рекурсивно, включая все его дочерние объекты:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; xs [1] [0] = 'X'
&gt;&gt;&gt; xs
[[1, 2, 3], ['X', 5, 6], [7, 8, 9]] 
&gt;&gt;&gt; zs
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre></div></div> <p>Возможно, вам понадобится некоторое время, чтобы с помощью интерпретатора python и поиграться с этими примерами. Получить полное представление о том, как работет копирование и клонирование лучше всего практикуясь на более-менее реальных примерах.</p> <p>Кстати, вы также можете создавать поверхностные копии, используя функцию в модуле копирования. Функция <code class="highlighter-rouge">copy.copy()</code> создает поверхностные копии объектов. Это полезно, если вам нужно четко зафиксировать, что вы создаете поверхностную копию где-то в своем коде. Использование <code class="highlighter-rouge">copy.copy()</code> позволяет вам однохначно указать этот факт. Однако для встроенных коллекций общепринятым считается, что достаточно просто использовать функции создания списка (<code class="highlighter-rouge">list()</code>), словаря (<code class="highlighter-rouge">dict()</code>) и набора (<code class="highlighter-rouge">set()</code>) для создания поверхностных копий.</p> <h4 id="копирование-любых-объектов">Копирование любых объектов</h4> <p>Вопрос, на который нам еще нужно ответить, заключается в том, как мы создаем копии (поверхностные и глубокие) произвольных объектов, включая пользовательские классы. Давайте посмотрим на это.</p> <p>Для этого используем модуль копирования. Его функции <code class="highlighter-rouge">copy.copy()</code> и <code class="highlighter-rouge">copy.deepcopy()</code> могут использоваться для дублирования любого объекта.</p> <p>Лучший способ понять, как их использовать, - это простой эксперимент. Основывать это на предыдущем примере копирования списка начнем с определения класса для координат точки в двумерном пространстве:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point:
	def __init __ (self, x, y):
	self.x = x 
	self.y = y
	
def __repr __ (self):
	return f'Point ({self.x! r}, {self.y! r}) '
</code></pre></div></div> <p>Довольно простая конструкция. Добавлена реализацию метода <code class="highlighter-rouge">__repr __()</code>, чтобы мы могли легко проверять объекты, созданные из этого класса, в интерпретаторе python.</p> <p>Затем мы создадим экземпляр класса Point и затем (поверхностно) скопируем его с помощью модуля копирования:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = Point(23, 42) 
&gt;&gt;&gt; b = copy.copy(a)
</code></pre></div></div> <p>Если мы проверим содержимое исходного объекта Point и его (поверхностной) копии, мы увидим, то, что и ожидаем:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a 
Point (23, 42) 
&gt;&gt;&gt; b 
Point (23, 42) 
&gt;&gt;&gt; a is b 
False
</code></pre></div></div> <p>Вот что еще нужно иметь в виду. Поскольку наш объект - точка использует примитивный тип (<code class="highlighter-rouge">int</code>) для своих координат, нет никакой разницы между поверхностной и глубокой копией в этом случае.</p> <p>Перейдем к более сложному примеру. Определим другой класс для представления 2D-прямоугольников. Сделаем это таким образом, чтобы мы могли создать объект, имеющий более сложную иерархию объектов - прямоугольник. Будем использовать для этого объекты Point для представления своих координат:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Rectangle:
	def __init __ (self, topleft, rightright):
	self.topleft = topleft 
	self.bottomright = justright
	
def __repr __ (self):
	return (f'Rectangle ({self.topleft! r}, '
                 е '{self.bottomright! г})')
                  Опять же, сначала мы попытаемся создать поверхностную копию экземпляра прямоугольника:

rect = Rectangle(Point(0, 1), Point(5, 6)) 
srect = copy.copy(rect)
</code></pre></div></div> <p>Если вы проверите исходный прямоугольник и его копию, вы увидите, насколько хорошо работает метод <code class="highlighter-rouge">__repr __ ()</code>, и что процесс поверхностной копии отработал должным образом:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; rect
Rectangle(Point (0, 1), Point(5, 6)) 
&gt;&gt;&gt; srect
Rectangle(Point (0, 1), Point(5, 6)) 
&gt;&gt;&gt; rect is correct
False
</code></pre></div></div> <p>Помните, как пример предыдущего списка иллюстрировал разницу между глубокими и поверхностными копиями? Используем тот же подход здесь. Изменим объект глубже в иерархии объектов, а затем вы увидите это изменение, отраженное в (поверхностной) копии:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; rect.topleft.x = 999
&gt;&gt;&gt; rect
Rectangle(Point(999, 1), Point(5, 6)) 
&gt;&gt;&gt; srect
Rectangle(Point(999, 1), Point(5, 6))
</code></pre></div></div> <p>Надеюсь, получилось так, как вы ожидали этого. Создам глубокую копию исходного прямоугольника. Затем применим другую модификацию, и вы увидите, какие объекты затронуты:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; drect = copy.deepcopy(srect)
&gt;&gt;&gt; drect.topleft.x = 222
&gt;&gt;&gt; drect
Rectangle(Point(222, 1), Point(5, 6)) 
&gt;&gt;&gt; rect
Rectangle(Point(999, 1), Point(5, 6)) 
&gt;&gt;&gt; srect
Rectangle(Point(999, 1), Point(5, 6))
</code></pre></div></div> <p>Вуаля! На этот раз глубокая копия (<code class="highlighter-rouge">drect</code>) полностью независима от оригинальной (<code class="highlighter-rouge">rect </code>) и поверхностной копии (<code class="highlighter-rouge">srect</code>). На самом деле эта тема настолько глубокая, что рассмотреть все аспекты в коротких примерах почти невозможно. Поэтому вы можете изучить документацию модуля копирования. Например, интерес для вас могут представлять специальные методы <code class="highlighter-rouge">__copy __()</code> и <code class="highlighter-rouge">__deepcopy __()</code>.</p> <p>Основные выходы</p> <p>• Создание поверхностной копии объекта не будет клонировать дочерние объекты. Поэтому копия получится не полностью независима от оригинала.</p> <p>• Глубокая копия объекта будет рекурсивно клонировать дочерние объекты. Клон полностью независим от оригинала, но создание глубокой копии происходит медленнее.</p> <p>• Вы можете скопировать произвольные объекты (включая пользовательские классы) с помощью модуля копирования.</p> <p><a href="https://dbader.org/img/pytricks-book/Python%20Tricks%20Sample.pdf">Источник: “Python Tricks The Book” Dan Bader</a></p> </div> <div class="likely likely-post"> <div class="telegram" data-url="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" data-title="Клонирование объектов в python">Отправить</div> <div class="vkontakte" data-url="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" data-title="Клонирование объектов в python">Поделиться</div> <div class="odnoklassniki" data-url="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" data-title="Клонирование объектов в python">Класснуть</div> <div class="facebook" data-url="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" data-title="Клонирование объектов в python">Поделиться</div> <div class="gplus" data-url="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" data-title="Клонирование объектов в python">Плюсануть</div> <div class="twitter" data-url="https://losthuman.ru/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" data-title="Клонирование объектов в python">Твитнуть</div> </div> <!-- <div class="article-ad"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5706627784425194" data-ad-slot="8358109938"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> </div> --> <!--<div id="disqus_thread"></div> <script> /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://losthuman-ru.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>--><div id="vk_comments"></div> <script type="text/javascript"> window.onload = function () { VK.init({apiId: 7004890, onlyWidgets: true}); VK.Widgets.Comments('vk_comments', {limit: 20, attach: "graffiti,photo,video,audio", norealtime: 0}); } </script><a class="u-url" href="/categories/library/2018/09/23/klonirovanie-obektov-v-python.html" hidden></a> </article> </div> <div class="col-md-4"> <div class="article-ad"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- losthuman-aside --> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5706627784425194" data-ad-slot="4814492309" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> </div><ul> <li class="tags" ><a href="/tags/iphone">iphone (1) </a> </li> <li class="tags" ><a href="/tags/apple">apple (4) </a> </li> <li class="tags" ><a href="/tags/security">security (5) </a> </li> <li class="tags" ><a href="/tags/hackers">hackers (1) </a> </li> <li class="tags" ><a href="/tags/google">google (2) </a> </li> <li class="tags" ><a href="/tags/angular">angular (1) </a> </li> <li class="tags" ><a href="/tags/programming">programming (11) </a> </li> <li class="tags" ><a href="/tags/gagets">gagets (3) </a> </li> <li class="tags" ><a href="/tags/regex">regex (1) </a> </li> <li class="tags" ><a href="/tags/wordpress">wordpress (1) </a> </li> <li class="tags" ><a href="/tags/python">python (4) </a> </li> <li class="tags" ><a href="/tags/twitter">twitter (1) </a> </li> <li class="tags" ><a href="/tags/shazam">shazam (1) </a> </li> <li class="tags" ><a href="/tags/application">application (1) </a> </li> <li class="tags" ><a href="/tags/photo">photo (1) </a> </li> <li class="tags" ><a href="/tags/css">css (1) </a> </li> <li class="tags" ><a href="/tags/bittorrent">bittorrent (1) </a> </li> <li class="tags" ><a href="/tags/amazon">amazon (1) </a> </li> <li class="tags" ><a href="/tags/swift">swift (5) </a> </li> <li class="tags" ><a href="/tags/IOS">IOS (1) </a> </li> <li class="tags" ><a href="/tags/uber">uber (1) </a> </li> <li class="tags" ><a href="/tags/npm">npm (1) </a> </li> <li class="tags" ><a href="/tags/nodejs">nodejs (1) </a> </li> <li class="tags" ><a href="/tags/code">code (2) </a> </li> <li class="tags" ><a href="/tags/jekyll">jekyll (2) </a> </li> <li class="tags" ><a href="/tags/GitHub">GitHub (1) </a> </li> <li class="tags" ><a href="/tags/GitHub Pages">GitHub Pages (1) </a> </li> </ul><div class="btcwdgt-chart"> style="margin-top: 30px"> <script> (function(b,i,t,C,O,I,N) { window.addEventListener('load',function() { if(b.getElementById(C))return; I=b.createElement(i),N=b.getElementsByTagName(i)[0]; I.src=t;I.id=C;N.parentNode.insertBefore(I, N); },false) })(document,'script','https://widgets.bitcoin.com/widget.js','btcwdgt'); </script> </div> </div> </div> </div> <div class="article-ad"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5706627784425194" data-ad-slot="8358109938"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> </div> </div> </main><footer class="site-footer h-card"> <data class="u-url" href="/"></data> <div class="wrapper"> <h2 class="footer-heading">Losthuman</h2> <div class="footer-col-wrapper"> <div class="footer-col footer-col-1"> <ul class="contact-list"> <li class="p-name">Losthuman</li><li><a class="u-email" href="mailto:info@losthuman.ru">info@losthuman.ru</a></li></ul> </div> <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://twitter.com/losthuman9"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">losthuman9</span></a></li></ul> </div> <div class="footer-col footer-col-3"> <p>Ничего особо ценного</p> </div> </div> </div> </footer> <script src="/assets/likely.js"></script> </body> </html>
