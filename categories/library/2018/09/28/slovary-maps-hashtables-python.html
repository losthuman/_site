<!DOCTYPE html> <html lang="ru"><head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta property="og:image" content="/assets/images/2018-09-22-formatirovanie-strok-v-python/top_image.jpg" /><!-- Begin Jekyll SEO tag v2.6.1 --> <title>Словари, сопоставления и таблицы хэширования | Losthuman</title> <meta name="generator" content="Jekyll v4.0.0" /> <meta property="og:title" content="Словари, сопоставления и таблицы хэширования" /> <meta property="og:locale" content="ru" /> <meta name="description" content="В Python словари (или dict для краткости) являются центральной структурой данных. Словари хранят любое количество объектов, каждый из которых идентифицируется уникальным словарным ключом. Словари также часто назавают сопоставлениями, хэшкартами, поисковыми таблицами или асоциативными массивами. Они позволяют очень эффективно находить, помещать в словарь и удалять из словаря любой объект относящийся в определенному ключу." /> <meta property="og:description" content="В Python словари (или dict для краткости) являются центральной структурой данных. Словари хранят любое количество объектов, каждый из которых идентифицируется уникальным словарным ключом. Словари также часто назавают сопоставлениями, хэшкартами, поисковыми таблицами или асоциативными массивами. Они позволяют очень эффективно находить, помещать в словарь и удалять из словаря любой объект относящийся в определенному ключу." /> <link rel="canonical" href="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" /> <meta property="og:url" content="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" /> <meta property="og:site_name" content="Losthuman" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2018-09-28T00:00:00+05:00" /> <script type="application/ld+json"> {"description":"В Python словари (или dict для краткости) являются центральной структурой данных. Словари хранят любое количество объектов, каждый из которых идентифицируется уникальным словарным ключом. Словари также часто назавают сопоставлениями, хэшкартами, поисковыми таблицами или асоциативными массивами. Они позволяют очень эффективно находить, помещать в словарь и удалять из словаря любой объект относящийся в определенному ключу.","headline":"Словари, сопоставления и таблицы хэширования","dateModified":"2018-09-28T00:00:00+05:00","datePublished":"2018-09-28T00:00:00+05:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html"},"url":"https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> <link rel="stylesheet" href="/assets/likely.css"> <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://losthuman.ru/feed.xml" title="Losthuman" /><!-- Put this script tag to the <head> of your page --> <script type="text/javascript" src="https://vk.com/js/api/openapi.js?160"></script></head> <body><header class="site-header" role="banner"> <div class="wrapper"> <a class="site-title" rel="author" href="/">Losthuman</a> <nav class="site-nav site-nav-custom"> <input type="checkbox" id="nav-trigger" class="nav-trigger" /> <label for="nav-trigger"> <span class="menu-icon"> <svg viewBox="0 0 18 15" width="18px" height="15px"> <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/> </svg> </span> </label> <div class="trigger"> <a class="page-link" href="/about/">О проекте</a> <a class="page-link" href="/categories/technews/index.html">Technews</a> <a class="page-link" href="/categories/code/index.html">Code</a> <a class="page-link" href="/categories/library/index.html">Library</a> </div> </nav> </div> </header> <main class="page-content" aria-label="Content"> <div class="wrapper"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-fg+4w-s-a4+kz" data-ad-client="ca-pub-5706627784425194" data-ad-slot="4102621418"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <div class="container-fluid"> <div class="row"> <div class="col-md-8"> <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title p-name" itemprop="name headline">Словари, сопоставления и таблицы хэширования</h1> <p class="post-meta"> <time class="dt-published" datetime="2018-09-28T00:00:00+05:00" itemprop="datePublished">Sep 28, 2018 </time></p> </header> <div class="post"> <div class="post-image"> <img src="/assets/images/2018-09-22-formatirovanie-strok-v-python/top_image.jpg" alt="Картинка" > </div> </div> <div class="post-content e-content" itemprop="articleBody"> <p>В Python словари (или <code class="highlighter-rouge">dict</code> для краткости) являются центральной структурой данных. Словари хранят любое количество объектов, каждый из которых идентифицируется уникальным словарным ключом. Словари также часто назавают сопоставлениями, хэшкартами, поисковыми таблицами или асоциативными массивами. Они позволяют очень эффективно находить, помещать в словарь и удалять из словаря любой объект относящийся в определенному ключу.</p> <p>Что это значит на практике? Оказывается, что простым аналогом словарей в нашем мире является телефонный справочник:</p> <blockquote> <p>Телефонные книги позволяют быстро получить информацию (номер телефона), связанную с определенным ключом (имя человека). Таким образом, вместо того, чтобы читать телефонную книгу с самого начала и до конца, чтобы найти чей-то номер, вы можете перейти более или менее непосредственно к имени и посмотреть на информацию, связанную с этим именем.</p> </blockquote> <p>Эта аналогия несколько отличается на практике, когда дело доходит до того, как информация организована, что не всегда позволяет обеспечить быстрый поиск. Но фундаментальные характеристики производительности остаются прежними: словари позволяют быстро находить информацию, связанную с определнным ключом. Таким образом, словари являются одной из наиболее часто используемых и наиболее важных структур данных в информатике.</p> <p>Итак, как Python обрабатывает словари? Давайте рассмотрим реализации словаря, доступные в ядре Python и стандартной библиотеке Python.</p> <h4 id="dict--это-словарь">Dict – это словарь</h4> <p>Из-за важности словарей Python имеет отличную нативную реализацию <code class="highlighter-rouge">dict</code> в ядре языка.</p> <p>Python также предоставляет полезный “синтаксический сахар” для работы со словарями. Например, синтаксис словарных выражений с фигурными скобками позволяют удобно определять новые объекты словаря:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phonebook = { 'bob': 7387,
    'alice': 3719,
    'jack': 7052,
}

squares = {x: x * x for x in range(6)} 

&gt;&gt;&gt; phonebook['alice']
3719

&gt;&gt;&gt; squares
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
</code></pre></div></div> <p>Существуют некоторые ограничения на использование объектов в качестве допустимых ключей.</p> <p>Словари Python индексируются ключами, которые могут иметь любой хэшируемый тип: хэшируемый объект имеет хэш-значение, которое никогда не меняется в течение его жизни (см. <code class="highlighter-rouge">__ hash__</code>), и его можно сравнить с другими объектами (см. <code class="highlighter-rouge">__eq__</code>). Кроме того, хэшируемые объекты, которые сравниваются как равные, должны иметь одинаковое хэш-значение.</p> <p>Неизменяемые типы, такие как строки и числа относятся к хэшируемым типам и хорошо работают в качестве ключей словаря. Можно также использовать объекты кортежей в качестве ключей словаря, если они содержат только сами хэшируемые типы.</p> <p>Для большинства случаев использование встроенной реализации словаря Python сделает все необходимое. Словари хорошо оптимизированы и лежат в основе многих частей языка, например атрибуты класса и переменные в стеке хранятся внутри словарей.</p> <p>Словари Python основаны на хорошо протестированной и точно настроенной реализации хэш-таблиц, которая обеспечивает ожидаемые характеристики производительности.</p> <p>Не так много причин не использовать стандартную реализацию <code class="highlighter-rouge">dict</code> Python. Однако существуют специализированные сторонние словарные реализации, например, списки пропуска или справочники на основе B-дерева.</p> <p>Помимо «простых» объектов <code class="highlighter-rouge">dict</code>, стандартная библиотека Python также включает ряд специализированных реализаций словаря. Эти специализированные словари основаны на встроенном словаре (и поддерживаются его характеристиками), но добавляют при этом некоторые удобные функции.</p> <p>Давайте посмотрим на некоторые из них.</p> <h4 id="collectionsordereddict--помните-о-порядке-ввода-ключей">collections.OrderedDict – Помните о порядке ввода ключей</h4> <p>Python включает специализированный подкласс <code class="highlighter-rouge">dict</code>, который запоминает порядок вставки ключей, добавленных к нему: <code class="highlighter-rouge">collections.OrderedDict</code>.</p> <p>Хотя стандартные экземпляры <code class="highlighter-rouge">dict</code> сохраняют порядок вставки ключей в CPython 3.6 и выше, это просто побочный эффект реализации CPython и не определен в спецификации языка. Итак, если порядок ключей важен для работы вашего алгоритма, лучше всего это четко выразить, явно используя класс OrderDict.</p> <p>Кстати, OrderedDict не является встроенной частью основного языка и должен быть импортирован из модуля коллекций в стандартную библиотеку.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; import collections

&gt;&gt;&gt; d = collections.OrderedDict(one=1, two=2, three=3)

&gt;&gt;&gt; d
OrderedDict([('one', 1), ('two', 2), ('three', 3)])

&gt;&gt;&gt; d['four'] = 4

&gt;&gt;&gt; d
OrderedDict([('one', 1), ('two', 2),
				('three', 3), ('four', 4)]) 

&gt;&gt;&gt; d.keys()
odict_keys(['one', 'two', 'three', 'four'])
</code></pre></div></div> <h4 id="collectionsdefaultdict--возвращает-значения-по-умолчанию-для-отсутствующих-ключей">collections.defaultdict – Возвращает значения по умолчанию для отсутствующих ключей</h4> <p>Класс <code class="highlighter-rouge">defaultdict</code> - это другой подкласс словаря, который принимает в своем конструкторе callable-объект, возвращающее значение которого будет использоваться, если запрошенный ключ не может быть найден.</p> <p>Это может сохранить вам некоторую типизацию и сделать намерения программиста более ясными и понятными по сравнению с использованием методов get () или перехвата исключения KeyError в обычных словарях.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from collections import defaultdict 

&gt;&gt;&gt; dd = defaultdict(list)

# Создается доступ к отстутствующим ключам
# для инициализации используются значения шаблона, 
# т.е. в данном примере в качестве шаблона используется объект list():
&gt;&gt;&gt; dd['dogs'].append('Rufus')
&gt;&gt;&gt; dd['dogs'].append('Kathrin')
&gt;&gt;&gt; dd['dogs'].append('Mr Sniffles')

&gt;&gt;&gt; dd['dogs']
['Rufus', 'Kathrin', 'Mr Sniffles']
</code></pre></div></div> <p>В указанном выше примере структура словаря <code class="highlighter-rouge">dd</code> определяется шаблоном объекта <code class="highlighter-rouge">list</code> (списка, массива), т.е. фактически такая конструкция определяет, что ключ <code class="highlighter-rouge">dogs</code> являются списком (массивом).</p> <h4 id="collectionschainmap--поиск-нескольких-словарей-как-единого-сопоставления">collections.ChainMap – Поиск нескольких словарей как единого сопоставления</h4> <p>Структура данных <code class="highlighter-rouge">collections.ChainMap</code> группирует несколько словарей в один объект (цепочку). Поиск осуществляет базовые сопоставления по каждому словарю, пока не будет найден ключ. Вставки, обновления и удаления влияют только на первое сопоставление, добавленное в цепочку.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from collections import ChainMap 

&gt;&gt;&gt; dict1 = {'one': 1, 'two': 2}

&gt;&gt;&gt; dict2 = {'three': 3, 'four': 4} 

&gt;&gt;&gt; chain = ChainMap(dict1, dict2)

&gt;&gt;&gt; chain
ChainMap({'one': 1, 'two': 2}, {'three': 3, 'four': 4})

# ChainMap в каждой коллекции в цепочке
# слева направо, пока не найдет искомый ключ (или выдаст ошибку поиска ключа): 

&gt;&gt;&gt; chain['three']
3
&gt;&gt;&gt; chain['one']
1
&gt;&gt;&gt; chain['missing']
KeyError: 'missing'
</code></pre></div></div> <h4 id="typesmappingproxytype--wrapper-для-создания-read-only-словарей">types.MappingProxyType – Wrapper для создания Read-Only словарей</h4> <p><code class="highlighter-rouge">MappingProxyType</code> - это обертка вокруг стандартного словаря, которая обеспечивает просмотр<code class="highlighter-rouge"> Read-Only</code> данных обернутого словаря. Этот класс был добавлен в Python 3.3, и его можно использовать для создания неизменяемых прокси-версий словарей.</p> <p>Например, это может быть полезно, если вы хотите вернуть внутреннее состояние, поддерживающее словарь, из класса или модуля, в то же время препятствуя доступу на запись к этому объекту. Использование <code class="highlighter-rouge">MappingProxyType</code> позволяет установить эти ограничения без предварительного создания полной копии документа.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from types import MappingProxyType

&gt;&gt;&gt; writable = {'one': 1, 'two': 2}

&gt;&gt;&gt; read_only = MappingProxyType(writable)

# В данном примере в качестве прокси-словаря выступает read-only:
&gt;&gt;&gt; read_only['one']
1

&gt;&gt;&gt; read_only['one'] = 23
TypeError:
"'mappingproxy' object does not support item assignment"

# Обновление оригинала, отражается на прокси:
&gt;&gt;&gt; writable['one'] = 42

&gt;&gt;&gt; read_only
mappingproxy({'one': 42, 'two': 2})
</code></pre></div></div> <h4 id="словари-в-python-заключение">Словари в Python: Заключение</h4> <p>Все версии словаря Python, перечисленные в этой главе, являются допустимыми реализациями, встроенными в стандартную библиотеку Python.</p> <p>Если вы ищете общую рекомендацию о том, какой тип отображения использовать в ваших программах, обратите внимание прежде всего на встроенный тип данных <code class="highlighter-rouge">dict</code>. Это универсальная и оптимизированная реализация хеш-таблицы, встроенная непосредственно на основной язык.</p> <p>Можно порекомендовать использовать один из других типов данных, перечисленных здесь, если у вас есть особые требования, выходящие за рамки того, что предоставляется <code class="highlighter-rouge">dict</code>.</p> <p>При том, что все они являются допустимыми параметрами, но обычно ваш код будет более понятным и более простым в обслуживании другими разработчиками, если он в большинстве случаев использует стандартные словари Python.</p> <h4 id="основные-выводы">Основные выводы</h4> <p>• Словари - это центральная структура в Python.</p> <p>• Встроенный тип <code class="highlighter-rouge">dict</code> будет «достаточно хорошим» в большинстве случаев.</p> <p>• Специализированные реализации, например, только для чтения или упорядоченные словари, доступны в стандартной библиотеке Python.</p> <p><a href="https://dbader.org/img/pytricks-book/Python%20Tricks%20Sample.pdf">Источник: “Python Tricks The Book” Dan Bader</a></p> </div> <div class="likely likely-post"> <div class="telegram" data-url="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" data-title="Словари, сопоставления и таблицы хэширования">Отправить</div> <div class="vkontakte" data-url="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" data-title="Словари, сопоставления и таблицы хэширования">Поделиться</div> <div class="odnoklassniki" data-url="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" data-title="Словари, сопоставления и таблицы хэширования">Класснуть</div> <div class="facebook" data-url="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" data-title="Словари, сопоставления и таблицы хэширования">Поделиться</div> <div class="twitter" data-url="https://losthuman.ru/categories/library/2018/09/28/slovary-maps-hashtables-python.html" data-title="Словари, сопоставления и таблицы хэширования">Твитнуть</div> </div> <!-- <div class="article-ad"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5706627784425194" data-ad-slot="8358109938"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> </div> --> <!----><div id="vk_comments"></div> <script type="text/javascript"> window.onload = function () { VK.init({apiId: 7004890, onlyWidgets: true}); VK.Widgets.Comments('vk_comments', {limit: 20, attach: "graffiti,photo,video,audio", norealtime: 0}); } </script><a class="u-url" href="/categories/library/2018/09/28/slovary-maps-hashtables-python.html" hidden></a> </article> </div> <div class="col-md-4"> <div class="article-ad"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- losthuman-aside --> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5706627784425194" data-ad-slot="4814492309" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> </div><ul> <li class="tags" ><a href="/tags/iphone">iphone (1) </a> </li> <li class="tags" ><a href="/tags/apple">apple (4) </a> </li> <li class="tags" ><a href="/tags/security">security (5) </a> </li> <li class="tags" ><a href="/tags/hackers">hackers (1) </a> </li> <li class="tags" ><a href="/tags/google">google (2) </a> </li> <li class="tags" ><a href="/tags/angular">angular (1) </a> </li> <li class="tags" ><a href="/tags/programming">programming (11) </a> </li> <li class="tags" ><a href="/tags/gagets">gagets (3) </a> </li> <li class="tags" ><a href="/tags/regex">regex (1) </a> </li> <li class="tags" ><a href="/tags/wordpress">wordpress (1) </a> </li> <li class="tags" ><a href="/tags/python">python (4) </a> </li> <li class="tags" ><a href="/tags/twitter">twitter (1) </a> </li> <li class="tags" ><a href="/tags/shazam">shazam (1) </a> </li> <li class="tags" ><a href="/tags/application">application (1) </a> </li> <li class="tags" ><a href="/tags/photo">photo (1) </a> </li> <li class="tags" ><a href="/tags/css">css (1) </a> </li> <li class="tags" ><a href="/tags/bittorrent">bittorrent (1) </a> </li> <li class="tags" ><a href="/tags/amazon">amazon (1) </a> </li> <li class="tags" ><a href="/tags/swift">swift (5) </a> </li> <li class="tags" ><a href="/tags/IOS">IOS (1) </a> </li> <li class="tags" ><a href="/tags/uber">uber (1) </a> </li> <li class="tags" ><a href="/tags/npm">npm (1) </a> </li> <li class="tags" ><a href="/tags/nodejs">nodejs (1) </a> </li> <li class="tags" ><a href="/tags/code">code (2) </a> </li> <li class="tags" ><a href="/tags/jekyll">jekyll (2) </a> </li> <li class="tags" ><a href="/tags/github">github (1) </a> </li> <li class="tags" ><a href="/tags/gitgubgages">gitgubgages (1) </a> </li> </ul><div class="btcwdgt-chart"> style="margin-top: 30px"> <script> (function(b,i,t,C,O,I,N) { window.addEventListener('load',function() { if(b.getElementById(C))return; I=b.createElement(i),N=b.getElementsByTagName(i)[0]; I.src=t;I.id=C;N.parentNode.insertBefore(I, N); },false) })(document,'script','https://widgets.bitcoin.com/widget.js','btcwdgt'); </script> </div> </div> </div> </div> <div class="article-ad"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5706627784425194" data-ad-slot="8358109938"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> </div> </div> </main><footer class="site-footer h-card"> <data class="u-url" href="/"></data> <div class="wrapper"> <h2 class="footer-heading">Losthuman</h2> <div class="footer-col-wrapper"> <div class="footer-col footer-col-1"> <ul class="contact-list"> <li class="p-name">Losthuman</li><li><a class="u-email" href="mailto:info@losthuman.ru">info@losthuman.ru</a></li></ul> </div> <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://twitter.com/losthuman9"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">losthuman9</span></a></li></ul> </div> <div class="footer-col footer-col-3"> <p>Ничего особо ценного</p> </div> </div> </div> </footer> <script src="/assets/likely.js"></script> </body> </html>
