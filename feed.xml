<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru_RU"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://losthuman.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="https://losthuman.ru/" rel="alternate" type="text/html" hreflang="ru_RU" /><updated>2019-05-25T17:02:12+05:00</updated><id>https://losthuman.ru/feed.xml</id><title type="html">Losthuman</title><subtitle>Ничего особо ценного</subtitle><entry><title type="html">Основы программирования и Playground. Часть 2</title><link href="https://losthuman.ru/categories/code/2019/01/30/osnovy-programmirovaniya-playground-chast-2.html" rel="alternate" type="text/html" title="Основы программирования и Playground. Часть 2" /><published>2019-01-30T00:00:00+05:00</published><updated>2019-01-30T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/30/Osnovy-programmirovaniya-Playground-chast-2</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/30/osnovy-programmirovaniya-playground-chast-2.html">Инструменты, которые мы будем использовать в  ходе написание кода, относятся к программным средствам. Одним из таких инструментов является Интегрированная среда разработки или IDE. Наиболее распространенная среда для Swift – это Xcode, которым вы будете пользоваться.

### Набор инструментов для написания

Xcode обладает очень полезной опцией, которая носит название Playground (“песочница”, игровая площадка). Это опция позволяет быстро разрабатывать и тестировать код без необходимости построения финального варианта программы. Playground будет неоднократно вами использоваться для написания вашего кода, поэтому важно понять, как она работает. Это, собственно, то, чему вы научитесь в остальной части этой главы. 

### Создание  Playground

При открытии Xcode, среда разработки будет приветствовать вас:

![]({{page.images_url}}1.png)

Если же вы не видите этого на экране своего монитора, то вероятнее всего опция, отвечающая за отображение окна приветствия, была отключена. Вы также можете открыть это окно, зажав комбинацию клавиш `Command-Shift-1` или нажав на `Window\Welcome` to Xcode в строке меню.

Вы можете незамедлительно переместиться из окна приветствия в Playground, нажав на Get started with a playground. Нажав на данную команду, Xcode перенесёт вас в следующее окно:

![]({{page.images_url}}2.png)

Здесь вы можете выбрать платформу. На данный момент ей могут быть iOS, macOS или tvOS. Выбранная вами платформа попросту определяет шаблон Playground. Каждая из них обладает своей средой и средствами к работе с вашим кодом. Основываясь на целях нашей программы, выбирайте то, что вам ближе: наше обучение основано на языке Swift, но не на конкретной платформе.

Как только вы определитесь с платформой, вы можете дать название своему Playground. Название является лишь формальностью и не играет роли, поэтому после создания Playground, вы можете абсолютно спокойно давать любое название вашему творению с учётом личного удобства. Например, вы можете дать ей название `MyPlayground.playground`.

![]({{page.images_url}}3.png)

Нажмите на `Create` и затем сохраните Playground. Xcode в последствие отобразит выбранный вами Playground:

![]({{page.images_url}}4.png)

Работа с новым Playground начинается не с абсолютно чистого листа: некоторые базисы кодировки для начинающих уже имеются. Однако не волнуйтесь – в скором времени вы поймёте, как работать с кодом. 

### Обзор  Playground

На первый взгляд может показаться, что Playground является причудливым текстовым редактором. В сущности говоря, так и есть!

![]({{page.images_url}}5.png)

Верхние скриншоты отображают первостепенную информацию:
1.`Source editor`: это пространство для написания вашего кода похожее на Notepad или TextEdit. Вы можете заметить наличие так называемого моноширинного шрифта, при котором ширина всех символов одинакова. За счёт данного типа шрифта форматирование и чтение кода становятся довольно простыми. 

2.`Results side bar`: это пространство отображает результат вашей работы. Вы узнаете больше о том, как реализуется сам код по мере прочтения книги. Results side bar ваш главный инструмент для проверки корректности написания кода и его работы.

3.`Execution control`: код написанный в Playground исполняется автоматически, т.е., написав его, вы можете незамедлительно увидеть отдачу. Эта опция позволяет вам реализовывать ваш код в Playground сколько угодно. Зажимая клавишу, вы можете переключаться между автоматическим и ручным режимами исполнения. 

4.`Activity viewer`: эта опция отображает статус Playground. Другими словами – завершил ли Playground исполнение написанного и готов ли  работать дальше с исходным кодом. При процессе исполнения пользователь будет оповещён символом в виде вертящегося спинера. 

5.`Panel controls`: данная опция позволяет скрывать и отображать три панели. Одну слева, одну снизу и одну справа. Панели содержат дополнительную информацию, которая может вам пригодиться для дальнейшей работы. Однако обычно они скрыты как на скриншоте.  Вы узнаете больше о каждой из панелей в дальнейшем. 

Playground реализует исполняемый код, начиная с самого начала, стремясь вниз. Каждый раз, когда вы будете изменять код, Playground будет совершать переисполнение, заменяя компоненты. Вы также можете сами запустить функцию переисполнения, нажав Editor\Execute Playground. Вы также можете изменять параметры исполнения кода. 

Мы можете включить нумеровку, которая находится слева от исходного кода, нажав `Xcode \Preferences...\Text Editing\Line Numbers`. Она может быть полезной в случаях, когда нужно сослаться на конкретные части кода. 
Как только исполнение кода будет завершено, Xcode обновит результат на боковой панели и покажет соответствующие строки рядом с исходным кодом. Вы узнаете как использовать результат вашего творения в дальнейшем. 

Ключевые моменты
    • Самые фундаментальные процессы, исполняемые компьютером, базируются на элементарной арифметике. 
    • Язык программирования позволяет вам писать код, который компилятор, в свою очередь, конвертирует в операции, исполняемые ЦП. 
    • Работа компьютера построена на двоичной (бинарной) системе счисления.
    • Интегрированная среда разработки, используемая нами для реализации Swift – это Xcode.
    • Получая моментальный отчёт о том, как код исполнен, Playground предоставляет возможность писать на языке Swift и тестировать его с крайне большой скоростью и эффективностью. 

### Что дальше?

Если вам ещё не предоставлялось возможности, советуем открыть Xcode и создать свой первый Playground. Назовите её Глава 1 и выберите платформу iOS. Сохраните её где-нибудь у себя на жестком диске и вернитесь к вашему “холсту”. Теперь лишь остаётся следовать уготованным в следующей главе инструкциям!

Данный текст является неавторизированным переводом книги [iOS Apprentice](https://store.raywenderlich.com/products/ios-apprentice)</content><author><name></name></author><category term="code swift" /><summary type="html">Инструменты, которые мы будем использовать в ходе написание кода, относятся к программным средствам. Одним из таких инструментов является Интегрированная среда разработки или IDE. Наиболее распространенная среда для Swift – это Xcode, которым вы будете пользоваться.</summary></entry><entry><title type="html">Основы программирования и Playground. Часть 1</title><link href="https://losthuman.ru/categories/code/2019/01/28/osnovy-programmirovaniya-playground-chast-1.html" rel="alternate" type="text/html" title="Основы программирования и Playground. Часть 1" /><published>2019-01-28T00:00:00+05:00</published><updated>2019-01-28T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/28/Osnovy-programmirovaniya-Playground-chast-1</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/28/osnovy-programmirovaniya-playground-chast-1.html">В первой главе мы разберем основы. В начале вы узнаете о том, как работает код, а затем – об инструментах для написания это кода на базе языка программирования Swift.

## Как работает компьютер

Можете не верить, но в действительности компьютер сам по себе не является таким уж невероятным вычислительным прибором. Его мощность целиком и полностью зависит от программной архитектуры, написанной людьми, такими же как вы или я. Учитывая тот факт, что вы сейчас читаете эту книгу, можно наверняка сказать, что вы желаете раскрыть потенциал своего компьютера и преуспеть в написании кода. В свою очередь для того, чтобы стать таковым, необходимо понимать, как работает компьютер. 

Вы вновь можете посчитать, что это невероятно, но на самом деле в строении компьютера нет ничего сложного. Его центр или “сердце” – это **Central Processing Unit (CPU)** или Центральный процессор (ЦП), являющийся по сути вычислительным устройством. Он совершает сложение, вычитание и другие арифметические операции с числами. То есть весь базис функционала компьютера, который вы видите и которым пользуетесь, построен на обработке ЦП многомиллионными числами каждую секунду. Удивительно, как из всего лишь чисел строится целая система. 

![]({{page.images_url}}1.png)

Процессор помещает числа , с которыми работает, в маленькие устройства памяти, называющиеся регистрами. ЦП вносит числа в регистры, перенося их из главной памяти всего компьютера - **Random Access Memory (RAM)**. Кроме того, процессор способен вносить числа обратно, из RAM в регистры. Конкретно эта функция позволяет вычислительному устройству работать с большим количеством данных, которое не всегда может полностью поместиться в регистрах. 
Для более наглядного объяснения имеется последовательный план работы этой вычислительной системы. 

Как только ЦП перемещает цифровые величины из RAM в свои регистры, вычислительной устройство производит обработку и помещает числа уже в другой регистр. Каждый последующий раз ЦП совершает вычитание, сложение, заимствует данные из RAM или, наоборот, вносит их. Иными словами, процессор совершает единичную операцию. Обычно всякая компьютерная программа состоит из тысяч или даже миллионов операций. Сложные программы вроде вашей операционной системы macOS (а это тоже программа) могут насчитывать миллионы операций всего.

![]({{page.images_url}}2.png)

Не исключена и возможность написания собственной программы, которой будет следовать компьютер, но написание таких программ, не считая более простых, занимает невероятно много времени и довольно сильно утомляет. Всё потому, что большинство программ нацелены на нечто большее, чем просто на простые вычисления. Эти программы предоставляют нам возможности интернет-сёрфинга, работы с фотографиями и общения с друзьями.

Таким образом, вместо написания собственной уникальной программы, вам следует реализовывать их на уже готовых основах, т.е. в виде специальных  языков программирования (в ваше случае это Swift). Этот язык реализуется через программу, называемую компилятором, которая переводит написанный вами код в операцию, которую ЦП знает, как совершить. Каждая строка написанного вами кода будет переведена во множество операций, некоторые из них могут обратиться даже в целые алгоритмы!

## Системы счисления

Как вы уже могли понять, числа являются своего рода “топливом” любого компьютера, его незаменимой основой. Какая бы информация не обрабатывалась, в конечном итоге она предстаёт в виде чисел. К примеру, каждый символ в конкретно взятом отрывке кода представлен в виде цифры. Мы разберём этот момент подробнее в 3 главе, которая будет посвящена строковому типу данных. 

Кстати говоря, с изображениями та же история: в компьютере они так же представлены в виде чисел. Изображение разбито на множество тысяч или даже миллионов частей, называемых пикселями. Каждый пиксель обладает своим ярко-выраженным единым цветом. Если вы хорошенько всмотритесь в свой компьютер, то сможете, скажем, различить их цветовые границы, при учете, что у вас будет монитор с высоким разрешением, где пиксели, как правило,  крайне малы. Каждый из этих элементов цветовой системы обычно состоит из 3 трех чисел: одно прикреплено к некоторому количеству красного цвета, второе - к зелёному и, наконец, третье - к синему. Как пример: пиксель абсолютно красного цвета имел бы параметры в виде 100% красного и, соответственно, 0% зелёного и синего. 

Стоит отметить, что сам процессор работает не совсем с обычным типом чисел, которые мы привыкли видеть и привыкли использовать каждый день. На этот раз нам придётся работать с так называемой “десятичной системой счисления”. На самом деле даже на интуитивном уровне можно понять то, как она работает. Однако, для наглядного примера рассмотрим работу процессора с десятичной системой счисления. Например, число 423 имеет 3 единицы, 2 десятка и 4 сотни:

![]({{page.images_url}}3.png)

В рассматриваемой нами системе каждая отдельно взятая цифра целого числа может иметь величину от 0 до 9, т.е. всего 10 возможных величин для каждой цифры. Именно по этому эта система имеет название десятичной!

На самом деле величины цифры полностью зависит от положения самой цифры в числе. Двигаясь справа налево, можно увидеть, как каждая цифра умножается на несколько десятков. 

	(0 * 1000) + (4 * 100) + (2 * 10) + (3 * 1) = 423

То есть самая крайняя правая позиция это десяток с величиной нуля, а следующий, соответственно, уже десяток с величиной единицы. Третья цифра имеет десяток с величиной двойки и так далее по нарастающей. Таким образом, получается, что каждая цифра имеет такую величину десятка, которая соответствует её последовательном номеру в числе, учитывая, что мы начинаем счёт с самой крайней правой позиции. 

### Двоичная система счисления

По причине того, что вы уже частично разбираетесь в десятичной системе, вы тратите не так много времени на анализ её чисел. Однако для компьютера эта система покажется довольно таки запутанной, ведь он, как мы уже выяснили до этого, на самом деле простак. Поэтому ему больше подойдет так называемая двоичная система счисления.

Как не трудно догадаться из названия, в сравнении с предыдущей системой счисления, каждая цифра имеет лишь две величины – 0 и 1.

**Примечание:** Как в теории, так и на практике существовали компьютеры, которые были построены на троичной системе счисления. Т.е. величин для цифр было 3 вместо 2. Некоторые программисты, информатики и отчаянные хакеры и по сей день продолжают исследовать возможности данной системы. 

Практически все современные компьютеры на сегодняшний день настроены на данную систему в виду того, что с точки зрения работоспособности гораздо проще манипулировать лишь двумя вариантами величин для цифр. Работа цифровых схем, которыми в оснащён компьютер, построена на наличии электрического напряжения, что обозначается величиной 1, или на его отсутствии, что, как нетрудно догадаться, обозначается величиной 0. 

Для лучше понимания рассмотрим двоичную систему счисления на примере числа 1101:

![]({{page.images_url}}4.png)

В десятичной системе мы измеряли величину цифр десятками, умножая сами цифры на них, в данном же случае нам придётся прибегнуть к помощи двоек, т.е. 1, 2, 4, 8, 16 и так далее. Общий принцип работы весьма прост: каждая цифра множится на величину, зависящую от всё того же положения цифры в числе. Умножение начинается справа налево. 

Поэтому в числе 1101 самая правая цифра 1 имеет величину в виде арифметического действия (1 * 2^0), что равняется, соответственно, 1. Величина следующей цифры 0 соответствует действию (0 * 2^1), которое равно 0. В общем-то, как уже было показано на примере принципа работы цифровых схем, величина цифр числа двоичной системы счисления либо выражает цифру (1), как часть целого числа, либо нет (0). 
Приведённое нами в пример число 1101 можно с лёгкостью из двоичной системы перевести в десятичную по аналогии работы десятичной системы, но заменив десятки двойками:

	(1 * 8) + (1 * 4) + (0 * 2) + (1 * 1) = 13

В свою очередь, если вы хотите конвертировать число десятичной системы 423 в двоичную систему, необходимо разбить само число так на двойки:  

	(1 * 256) + (1 * 128) + (0 * 64) + (1 * 32) + (0 * 16) + (0 * 8) + (1 * 4) 	+ (1 * 2) + (1 * 1) = 423

Как вы можете видеть, собрав двоичные цифры в необходимом порядке воедино, мы получим число 110100111. Совершив обратное действие перевода из одной системы в другую, можно легко проверить правильность расчётов. 

Каждая цифра двоичного числа имеет размер в бит, который в свою очередь является единицей измерения информации в двоичной системе. Восемь таких битов составляют один байт, а четыре – один ниббл или полубайт. Такого рода игра с языком в виде придумывания названий показывает, что даже у программистов прошлого с фантазией всё было в порядке.

![]({{page.images_url}}5.png)

Тот факт, что компьютер обладает ограниченной памятью, говорит также об ограниченности длины чисел. Каждый регистр, как правило, обладает пределом в 32-бита или в 64-бита. По этой же причине про ЦП говорят как о 32-битном или 64-битном. Таким образом, пределом 32-битного процессора будет число 4,294,967,295 или, переводя в двоичную систему, 11111111111111111111111111111111. Такова его работа.

Тем не менее процессор способен работать с числами, которые превосходят его вычислительные объёмы. В данном случае вычислительные операции будут разбиты на несколько этапов и займут больше времени аналогично тому, как мы поступали со сложными примерами в школе.

### Шестнадцатеричная система счисления

Как вы уже могли догадаться из предыдущего параграфа, работа с двоичной системой может быть скучной и занимающей много времени. По причине этого в программирование существует ещё одна базовая система счисления, называемая шестнадцатеричной. К слову, отдельных символов для всех 16 цифр не нашлось: всего их 10. Поэтому для их обозначения с 10-15 мы используем 6 первых букв английского алфавита:

	• a = 10
	• b = 11
	• c = 12
	• d = 13
	• e = 14
	• f = 15

Не стоит удивляться, если первое, что у вас получиться написать из шестнадцатеричного кода, будет похоже на слово.

![]({{page.images_url}}6.png)

Это самая забавная часть. 
Величина каждой цифры определяется при помощи шестнадцати, поэтому формула приведения в десятичную систему будет такой:

	(12 * 4096) + (0 * 256) + (13 * 16) + (14 * 1) = 49374

Вы можете также переводить буквы в десятичную систему и производить все необходимые вычисления. 

Но зачем же в таком случае увеличивать количество систем счисления?
Всё дело в том, что одна цифра шестнадцатеричной системы может в точности доносить величину четырех цифр двоичной системы. Двоичное число 1111 эквивалентно шестнадцатеричному f. Учитывая это, можно с лёгкостью укорачивать двоичные числа, используя шестнадцатеричную систему. 

Для примера рассмотрим число c0de:

	c = 1100
	0 = 0000
	d = 1101
	e = 1110
	c0de = 1100 0000 1101 1110

Эта опция оказывается весьма полезной, учитывая насколько длинными могут быть двоичные числа на 32-битных и 64-битных процессорах. То есть длиннейшее число для 32-битов 4,294,967,295 двоичной системы может быть записано как ffffffff в шестнадцатеричной.

### Как работает код

У компьютера есть много ограничений, и сам по себе он не обладает большим функционалом. Процесс программирования – это процесс расширения функций компьютера путём кодирования, где малые элементы сложены воедино в правильном порядке. 
Кодирование крайне схоже с написанием рецепта: вы собираете все ингредиенты (данные) и даёте компьютеру инструкцию касательного того, как эти самые ингредиенты использовать.
Например:

	Шаг 1. Загрузить фото, находящееся на жестком диске
	Шаг 2. Изменить размер фото по параметрам 400 пикселей в ширину и 300 пикселей в высоту
	Шаг 3. Применить светло-коричневый фильтр к фото
	Шаг 4. Напечатать фото

Приведённый выше пример является так называемым псевдокодом, т.е. сам по себе код не представляет собой реальный язык программирования, однако он отображает алгоритм, который вы хотите осуществить. В нашем случае желаемым алгоритмом является загрузка фото, изменение его размера, применения фильтра и распечатка. В общем-то, это довольно простой прямолинейный алгоритм, но от этого он алгоритмом не перестаёт быть. 

![]({{page.images_url}}6.png)

Рассматриваемый нами язык Swift не многим отличается: пошаговый список шагов для компьютера. Тем не менее эти инструкции будут усложняться по мере чтения этой книги, хотя принцип будет не изменен: вы просто выдаете компьютеру последовательные команды.

Каждый язык программирования это продвинутый и заранее проработанный способ построения таких инструкций. Компилятор же, в свою очередь, уже знает как интерпретировать написанный вами код, чтобы сделать из него ту же инструкцию для ЦП.

Swift является крайне новаторским языком программирования. Он вобрал в себя достоинства многих других языков, а также исправил и использовал себе в угоду их недостатки. Пройдут годы, и мы будем смотреть на него, как на пережиток времени, однако, что же касается нынешнего момента, Swift – это довольно таки занимательный и быстро изменяющийся язык.

Это был наш краткий вводный курс по теме “компьютерного железа”, систем счисления, кода и того, как они все вместе взаимодействуют с целью создания современных программ. На самом деле не малый объём информации для одной части. Пришло время узнать об инструментах, с помощью которых мы сможем реализовывать наш код, написанный на Swift.

Данный текст является неавторизированным переводом книги [iOS Apprentice](https://store.raywenderlich.com/products/ios-apprentice).</content><author><name></name></author><category term="code" /><category term="swift" /><summary type="html">В первой главе мы разберем основы. В начале вы узнаете о том, как работает код, а затем – об инструментах для написания это кода на базе языка программирования Swift.</summary></entry><entry><title type="html">Swift управление потоками Часть 3</title><link href="https://losthuman.ru/categories/code/2019/01/22/swift-flow-control-chast-3.html" rel="alternate" type="text/html" title="Swift управление потоками Часть 3" /><published>2019-01-22T00:00:00+05:00</published><updated>2019-01-22T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/22/Swift--Flow-Control--Chast-3</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/22/swift-flow-control-chast-3.html">Приветствуем вас в третьей части нашей мини-серии по Swift, в которой вы узнаете как использовать булевые пеерменные и управлять потоками. Данный материал является переводом [tutorial](https://www.raywenderlich.com/6366-swift-tutorial-part-3-flow-control) с сайта [raywenderlich.com](https://www.raywenderlich.com).

Это будет финальная часть мини-серии. Первые две части можно найти на нашем сайте: [Часть 1: Swift: выражения,переменные и константы.](https://losthuman.ru/categories/code/2018/10/07/swift-tipy-i-operatsii-chast-2.html) или [Часть 2: Swift: Типы и операции](https://losthuman.ru/categories/code/2018/10/06/swift-uchebnik-chast-1-vyrazhenija.html)

В терминологии компьютерного программирования возможность сказать компьютеру что делать в различных ситуациях называется управление потоками (control flow).

В этой части мини-серии вы узнаете как принимать решения и повторять задачи в ваших программах используя синтаксис управления потоками. Вы также узнаете о булевых переменных, которые оперируют всего двумя значениями `true` и `false`, а также как можно с их помощью сравнивать данные.

## С чего начать

К этому моменту вы уже должны понимать что из себя представляют некоторые типы данных, например такие, как `Int`, `Double` и `String`. Сейчас вы познакомитесь с другим типом данных, который позволит вам сравнивать значения применяя операторы сравнения.

Когда выполняется сравнение, например поиск большего из двух чисел, ответ представляет собой либо _правда_ , либо _ложь_. Swift имеет тип данных специально предназначенный для таких целей. Он называется `Bool`, что является сокращением от слова Boolean. Само понятие булевого числа было введено в математику Джорджем Булем, предложившим концепцию  `true` или `false`.

Вот как используются Boolean в Swift:

    let yes = true // Подразуемвается что это тип Bool
    let no = false // Подразуемвается что это тип Bool

Вообще говоря, булевая пеерменная может иметь только два значения: `правда` или `ложь`, которые обозначаются ключевыми словами `true` или `false`, соответственно. В примере выше использовались эти ключевые слова для присвоения значения константам.


### Булевые операторы

Булевый тип данных в основном используется для сравнения значений. Например, у вас есть два значения и вы хотите знать равны ли они между собой: либо эти значения равны (true), либо они различны (false).

В Swift вы можете выполнить это используя оператор равенства, который обозначается `==`:

    let doesOneEqualTwo = (1 == 2)

Swift подразумевает, что `doesOneEqualTwo` это тип `Bool`. Совершенно очевидно, что 1 не равно 2 и поэтому,`doesOneEqualTwo` будет присвоено значение `false`

Аналогично, если два числа _не_ равны можно использовать оператор `!=`:

    let doesOneNotEqualTwo = (1 != 2)

В этом случае сравнение будет `true`, так как 1 не равно 2, поэтому `doesOneNotEqualTwo` будет присвоено значение `true`

Префикс оператора `!` также называемый оператор отрицания, переключает `true` на `false`, а `false` на `true`. То же самое можно записать иначе:

    let alsoTrue = !(1 == 2)

Рассмотрим это выражение шаг за шагом: 1 не равно 2, поэтому (1 == 2) это `false` и тогда `!` переключает `false` на `true`.

Еще два оператора позволят вам определить если число больше чем (`&gt;`) или меньше чем (`&lt;`) другое число. Совершенно точно, что вы знакомы с этими оперторами из школьного курса математики.

    let isOneGreaterThanTwo = (1 &gt; 2)
    let isOneLessThanTwo = (1 &lt; 2)

Это не наука о космических ракетах, поэтому каждому будет понятно, что константа `isOneGreaterThanTwo` будет равна `false`, а константа `isOneLessThanTwo` будет равна`true`.

Есть еще оператор, который позволяет проверять если значение меньше _или_ равно другому значению: `&lt;=`. Это комбинация `&lt;` и `==`, и поэтому она возвращает `true` если первое значение либо меньеше, чем второе значение, либо равно ему.

Аналогично работает оператор `&gt;=`, которые позволяет выполнить проверку является ли значение больше или меньше другого.

### Булевая логика

Примеры выше проверяют выполнение только одного условия. Для того, чтобы получить результат проверки выполнения нескольких объединенных условий следует применить булеву логику.

Одним из способов объединения условий является использование оператора AND. Когда вы используете AND вместе с булевыми значениями, результатом будет другое булевое значение. Если оба входящих булевых значения `true`, тогда результатом будет другое булевое значение `true`. В противном случае результатом будет `false`.

![george_boole](https://koenig-media.raywenderlich.com/uploads/2016/09/george_boole-650x480.png)

В Swift булевый оператор AND обозначается как `&amp;&amp;`:

    let and = true &amp;&amp; true

В этом случае `and` будет присвоено значение `true`. Если бы любое значение справа было `false`,тогда `and` было бы присвоено значение `false`.

Другой способ объединения условий это использование оператора OR. Когда вы используете  OR вместе с двумя булевыми значениями, результат будет `true`, если _один_ из входящих булевых значений является `true`. Только если _оба_ входящих значения являются `false`, результат будее тоже `false`.

В Swift булевый оператор OR обозначается как `||`:

    let or = true || false

В этом случае `or` будет `true`. Если оба значения справа были  `false`, тогда значение`or` было бы `false`. Если бы оба значения были `true`, тогда значение `or` стало бы`true`.

В Swift булевая логика обычно применяется к нескольким условиям. Например:

    let andTrue = 1 &lt; 2 &amp;&amp; 4 &gt; 3
    let andFalse = 1 &lt; 2 &amp;&amp; 3 &gt; 4

    let orTrue = 1 &lt; 2 || 3 &gt; 4
    let orFalse = 1 == 2 || 3 == 4

Каждая из этих проверок предусматривает два различных условия, объединенных либо оператором  AND, либо оператором OR.

Также допускается использовать булевую логику для объединения более чем двух условий. Например вы можете формировать сравнения так:

    let andOr = (1 &lt; 2 &amp;&amp; 3 &gt; 4) || 1 &lt; 4

Когда вы заключаете скобками часть выражения, вы определяете порядок его выполнения. Вначале, Swift выполнит выражение внутри скобок, а затем выполнит все выражение целиком:

    1. (1 &lt; 2 &amp;&amp; 3 &gt; 4) || 1 &lt; 4
    2. (true &amp;&amp; false) || true
    3. false || true
    4. true

### Равенство строк

Иногда вы хотите определит равны ли две строки друг другу. Например, задачей в детской игре может быть правильное определение названий животных, изображенных на фотографиях.

В Swift вы можете сравнивать строки используя стандартный оператор равенства `==`, точно таким же способом каким мы ранее сравнивали числа. Например:

    let guess = &quot;dog&quot;
    let dogEqualsCat = guess == &quot;cat&quot;

`dogEqualsCat` имеет булевое значение, которое в данном случае равно `false`, потому, что слово `&quot;dog&quot;` не равно слову `&quot;cat&quot;`.

Точно так же как и с числами, вы можете сравнивать не только равны ли строки, но также определять больше одна из строк или меньше, чем другая. Например:

    let order = &quot;cat&quot; &lt; &quot;dog&quot;

Такой сиснтаксис проверит если одна из строк находится ранее другой в алфавитном порядке. В этом случае значение `order` равно `true` потому, что  `&quot;cat&quot;` по алфавиту находится до `&quot;dog&quot;`.

## Условный оператор if

Первый и самый общий способ контроля потока в программе это использование условного оператора `if` (или выражения `if`), который позволяет программе делать что-то только _если_ выполняется определенное условие как `true`. Например, рассмотрим следующий пример:

    if 2 &gt; 1 {
      print(&quot;Yes, 2 is greater than 1.&quot;)
    }

Это самый  простой пример использования оператора `if`. Если условие выполняется как `true`, тогда оператор будет выполнять код между фигурными скобками. Если условие выполняется как `false`, тогда оператор не будет выполнять код между фигурными скобками.

Вы можете изменить оператор `if` включив в него возможность выполнения кода, если условие ыполняется как `false`. Для этого используется оператор `else`. Например:

    let animal = &quot;Fox&quot;
    if animal == &quot;Cat&quot; || animal == &quot;Dog&quot; {
      print(&quot;Animal is a house pet.&quot;)
    } else {
      print(&quot;Animal is not a house pet.&quot;)
    }

В данном случае если значение `animal` равно либо `&quot;Cat&quot;` либо `&quot;Dog&quot;`, тогда оператор выполнит первый блок кодв. Если  значение`animal` не равно `&quot;Cat&quot;` или `&quot;Dog&quot;`, тогда оператор выполнит блок кода, заключенный внутри `else`, напечатав следующее в дебаггере:

    Animal is not a house pet.

Но, с условным оператором `if` вы можете еще больше, чем в предыдущем примере. Иногда вы хотите проверить одно условие, на соответстиве нескольким. Для этого используется оператор `else-if`, с помощью которого можно вложить еще один оператор `if` в оператор `else`, относящийся к предыдущему условному оператору `if`.

Например, можно записать код так:

    let hourOfDay = 12
    var timeOfDay = &quot;&quot;

    if hourOfDay &lt; 6 {
      timeOfDay = &quot;Early morning&quot;
    } else if hourOfDay &lt; 12 {
      timeOfDay = &quot;Morning&quot;
    } else if hourOfDay &lt; 17 {
      timeOfDay = &quot;Afternoon&quot;
    } else if hourOfDay &lt; 20 {
      timeOfDay = &quot;Evening&quot;
    } else if hourOfDay &lt; 24 {
      timeOfDay = &quot;Late evening&quot;
    } else {
      timeOfDay = &quot;INVALID HOUR!&quot;
    }
    print(timeOfDay)

В данном случае вложенные операторы `if` проверяют условия одно за другим, пока одно из них не выполнится как `true`. Только код, связанный с этим условием будет выполнен, независимо от того могут ли последующие условия `else-if`выполниться как `true`. Иными словам порядок проверки условий имеет значение!

Вы можете добавить условный оператор `else`в конец для обработки случая, когда ни одно из условий не выполняется как `true`. В таком случае использование `else` является опциональным, если вы не нуждаетесь в нем. В использованном примере необходимо, чтобы переменная `timeOfDay` имела валидное значение времени, когда вы будете распечатывать его значение.

В этом прмиере условный оператор `if` получает время, выраженное в часах (числах) и конвертирует его в строку, представляющую описание времени дня, к которому  это время относится. Работая с 24-х часовым форматом времени условный оператор проверяет последовательно одно услвоие за другим.

В коде выше  переменная `hourOfDay` имеет значение `12`. Поэтому, код будет печатать следующее сообщение:

    Afternoon

Обратите внимание, что, хотя еще два условия `hourOfDay &lt; 20` и `hourOfDay &lt; 24` также выполняются как `true`, условный оператор выполнит только первый блок, чье условие соответствут `true`. В этом случае, выполнится блок с условием `hourOfDay &lt; 17`.

### Инкапсуляция переменных

Условный оператор `if` описывает новую концепцию пространства, которая является способом инкапсуляции переменных с помощью фигурных скобок.

Вообразите, что вы хотите подсчитать комиссию, которую взимает ваш клиент. Вот сделка, которую вы заключили:

Вы зарабатываете 25 долларов в час за 40 часов, и 50 долларов за каждый час сверх этого времени.

Используя Swift вы можете расчитать ваши платежи:

    var hoursWorked = 45

    var price = 0
    if hoursWorked &gt; 40 {
      let hoursOver40 = hoursWorked - 40
      price += hoursOver40 * 50
      hoursWorked -= hoursOver40
    }
    price += hoursWorked * 25

    print(price)

Этот код получает количество часов и проверяет, превышает ли это число 40 часов. Если это так, код считает количество часов сверх 40 и умножает его на 50 долларов, затем добавляет результат к цене. Далее код вычитает количество часов превышающих 40 из отработанных часов. Осташееся время умножается на 25 долларов и добавляется к цене.

В примере выше результата должен быть следующим:

    1250

`hoursOver40` объявляет новую константу, которую можно использовать внутри оператора `if`. Но, что случится, если вы попробуете использовать ее в конце кода, за пределами оператора `if`?

    // ...

    print(price)
    print(hoursOver40)

Результат будет следующим:

    error: MyPlayground.playground:8:7: error: use of unresolved identifier 'hoursOver40'
    print(hoursOver40)
      ^~~~~~~~~~~

Эта ошибка информирует вас что вы можете использовать константу `hoursOver40` в пространстве, в котором эта константа была объявлена (создана). В этом случае, условный оператор `if` создает новое пространство, так, что когда это пространство заканчивается, вы не можете больше испоьзовать эту константу.

В любом случае, каждое пространство может использовать переменные и константы объявленные в своем родительством пространстве. В примере выше пространство внутри оператора  `if` использует переменные `price` и  `hoursWorked`, которые были созданы в родительском пространстве.


### Тернарный условный оператор

Тернарный условный оператор получает условие и возвращает одно из двух значений, в зависимости от того, что было результатом выполнения условия: `true` or `false`:

    (&lt;CONDITION&gt;) ? &lt;TRUE VALUE&gt; : &lt;FALSE VALUE&gt;

Рассмотрим пример в котором надо определить минимальное из двух переменных:

    let a = 5
    let b = 10

    let min: Int
    if a &lt; b {
      min = a
    } else {
      min = b
    }

Благодаря тернарному оператору вы можете переписать этот код по-другому:

    let a = 5
    let b = 10

    let min = a &lt; b ? a : b

Если условие `a &lt; b` является `true`, тогда результатом будет присвоение  константе `min`
значения `a`; если  `false`, то результатом будет значение `b`.

Тернарный оператор следует применять с осторожностью. Его краткость может стать причиной написания трудночитаемого кода.

## Циклы

Циклы это способ выполнять код многократно. В самом начале этого раздела вы узнаете о цикле `while`.

### Циклы While

Цикл `while` повторяет блок кода пока некоторое условие выполняется как `true`.

Цикл `while` создается следующим образом:

    while &lt;CONDITION&gt; {
      &lt;LOOP CODE&gt;
    }

Во время каждой итерации цикл проверяет выполнение условия. Если условие выполняется как `true`, тогда цикл выполняется и переходит к следующей итерации. Если условие выполняется, как `false`, тогда цикл останавливается, Также, как и условный оператор `if`, цикл `while` создает пространство.

Простейший цикл `while`:

    while true {
    }

Этот цикл `while`, который никогда не закончится, потому, что условие всегда будет `true`. Бесконечный цикл может не стать причиной падения вашей программы, но это может с высокой вероятностью &quot;повесить&quot; ваш компьютер.

[![Force quit](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-force-quit-500x500.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-force-quit.png)

Вот более реальный пример цикла `while`:

    var sum = 1

    while sum &lt; 1000 {
      sum = sum + (sum + 1)
    }

Этот код расчитывает математическую последовательность, пределом которой является значение больше, чем 1000.  

Цикл выполняется следующим образом:

[![While Loop iteration](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-while-loop-iteration-560x500.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-while-loop-iteration.png)

После девяти итераций значение переменой `sum` станет равно`1023`, поэтому условие выполнения цикла `sum &lt; 1000` станет `false`. После этого выполнение цикла остановится.

### Циклы Repeat-while

Это вариант цикла `while`названный цикл repeat-while. Отличие от цикла `while` состоит в том, что условие выполнения цикла оценивается _в конце_ выполнения цикла, а не в начале.

Цикл `repeat-while` конструируется следующим образом:    

    repeat {
      &lt;LOOP CODE&gt;
    } while &lt;CONDITION&gt;

Вот предыдущий пример, но с сипользованием цикла `repeat-while`:

    sum = 1

    repeat {
      sum = sum + (sum + 1)
    } while sum &lt; 1000

В этом примере результат будет точно такой-же. При этом, такое совпадение может быть не всегда.

Рассмотрим следующий пример выполнения цикла `while`:

    sum = 1

    while sum &lt; 1 {
      sum = sum + (sum + 1)
    }

А сейчас рассмотрим соответствующий цикл `repeat-while`, который использует для выполнения точно такое-же условие:

    sum = 1

    repeat {
      sum = sum + (sum + 1)
    } while sum &lt; 1

В  случае с регулярным цикло `while`, условие `sum &lt; 1` равна `false` будет выполнено сразу на старте цикла, Это значит, что код в теле цикла не будет выполнен. Значение переменной `sum` будет равно `1` потому, что цикл не будет выполнен ни разу.

В случае же с циклом `repeat-while`, переменная `sum` будет равна `3`, потому, что цикл будет выполнен один раз.

### Прерывание цикла

Иногда вы хотите прервать цикл ранее, чем он будет закончен. Вы можете использовать для этого выражение `break`, которое немедлено остановит выполнение цикла и продолжит выполнение кода после цикла.

Например, рассмотрим следующий код:

    sum = 1

    while true {
      sum = sum + (sum + 1)
      if sum &gt;= 1000 {
        break
      }
    }

В этом примере условие выполнения цикла равно `true`, так что цикл может выполняться бесконечно. Однако, наличие выражения `break` означает, что цикл `while` будет остановлен как только значение `sum ` станет больше или равно `1000`.

## Продвинутое управление потоками

В этом разделе вы продолжите знакомиться с тем, как контролировать выполнение потока. Вы узнаете о цикле, который называется цикл `for`.

## Диапазоны

До того, как погрузиться в изучение цикла `for`, вам необходимо знать о [`ClosedRange` - закрытом диапазоне](https://developer.apple.com/documentation/swift/closedrange)
and [`Range`  - полуоткрытом диапазоне](https://developer.apple.com/documentation/swift/range) типах, которые позволяют представлять последовательности чисел.

Во-первых, существуют закрытые диапазоны:

    let closedRange = 0...5

Три точки (`...`) сигнализируют что этот диапазон закрытый, что означает диапазон числе от 0 до 5, включая 0 и 5: `(0, 1, 2, 3, 4, 5)`.

Во-вторых, существуют полуоткрытые диапазоны:

    let halfOpenRange = 0..&lt;5

В этом случае заменим три точки на две точки и знак меньше (`..&lt;`). Полуоткрытый диапазон значит диапазон от 0 до 5, включая 0, но _не_ включая 5: `(0, 1, 2, 3, 4)`.

Оба закрытый и полуоткрытый диапазоны должны всегда быть возрастающими. Другими словами, второе число диапазона должно быть всегда больше или равно первому.

Диапазоны обычно используют для циклов `for` и выражения `switch`.

## Цикл For

Теперь, когда вы знаете немного о диапазонах, самое время взглянуть на цикл `for`. Этот цикл используется для выполнения кода определенное число раз.

Конструкция цикла `for` выглядит так:

    for &lt;CONSTANT&gt; in &lt;RANGE&gt; {
      &lt;LOOP CODE&gt;
    }

Оператор `for` начинается со слова `for`. Далее последовательно указываются: имя константы, слово  `in` и диапазон повторений цикла. Например:

    let count = 10
    var sum = 0

    for i in 1...count {
      sum += i
    }

Цикл `for` выполняется в диапазоне от 1 до значения константы `count`. В первом выполнении цикла `i` будет равно первому элементу диапазона - 1. На каждом повторении `i` будет увеличиваться на единицу, до тех пор, пока не будет равной `count`, после чего цикл будет выполнен последний раз.

Если вы используете полуоткрытый диапазон, последняя итерация будет при значении `i` равном `count - 1`.

Внутри цикла  вы добавляете `i` к переменной `sum`. Эта операция повторяется 10 раз , таким образом выполняется последовательно сложение `1 + 2 + 3 + 4 + 5 + ...` до тех пор пока `i` не будет равно 10.

На рисунке ниже изображены значения константы `i` и переменной `sum` для каждой итерации:

![Итерации цикла for](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-for-loop-iteration.png)

Константа `i` видима только внутри пространства цикла `for`, что значит, что эта константа не доступна за пределами цикла.

В случае, если вы не хотите использовать в цикле константы вовсе, вы можете использовать знак нижнего подчеркивания (_) для укзания что игнооируете ее (константу). Например:

    sum = 1
    var lastSum = 0

    for _ in 0..&lt;count {
      let temp = sum
      sum = sum + lastSum
      lastSum = temp
    }

Этот код не имеет константы в цикле, цикл просто выполняется определенное число раз. В этом случае диапазон начинается от 0 и заканчивается значением `count`, при этом диапазон полуоткрытый. Таким способом обычно записываются циклы, которые выполняются определенное число раз.

Также возможно выполнить только те итерации, которые соответствуют определнному условию. Например, представим, что вы хотите вычислить сумму только нечетных чисел:

    var sum = 0
    for i in 1...count where i % 2 == 1 {
      sum += i
    }

Цикл выше содержит оператор `where`. Благодаря этому цикл будет выполнять код в диапазоне от 1 до `count`, но только в том случае, когда условие предусмотренное `where` будет `true`. В этом случае это будет, когда значение `i` является нечетным числом.

### Оператор Continue

Иногда вым может понадобится пропустить итерацию цикла в определенном случае, без прерывания самого цикла целиком. Вы можете сделать это с помощью оператора `continue`, который немедленно закончит текущую итерацию и перейдет к следующей.

Использование `continue` вместо простого `where` предпочтительнее, когда вам необходим высокоуровневый контроль над исполнением кода.

Например рассмотрим сетку 8х8, в которой каждая ячейка содержит значение номера ряда умноженого на колонку:

![full_board](https://koenig-media.raywenderlich.com/uploads/2016/09/full_board-496x500.png)

Это очень похоже на таблицу умножения, не правда ли?

Скажем, вы хотите расчитать сумму всех ячеек за исключением тех, которые расположены на четных рядах:

![first_board_example](https://koenig-media.raywenderlich.com/uploads/2016/09/first_board_example-496x500.png)

С помощью цикла `for` эту задачу можно решить следующим образом:

    sum = 0

    for row in 0..&lt;8 {
      if row % 2 == 0 {
        continue
      }

      for column in 0..&lt;8 {
        sum += row * column
      }
    }

Когда остаток от деления номера ряда на 2 равен 0, тогда этот ряд четный. В этом случае  `continue` заставит цикл `for` перепрыгнуть на следующий ряд.

Также, как и `break`, `continue` работает с обоими циклами - `for` и `while`.

## Оператор Switch

Еще один способ управления потоками осуществляется через использование оператора `switch`, который позволяет вам выполнять различные части кода в зависимости от значение переменной или константы.

Вот очень простой оператор `switch`, который обрабатывает целые числа:

    let number = 10

    switch number {
    case 0:
      print(&quot;Zero&quot;)
    default:
      print(&quot;Non-zero&quot;)
    }

После выполнение кода в консоли будет напечатано:

    Non-zero

Целью оператора `switch` было определение является ли число нулем.

Для обработки конкрентного значения вы используете `case`, представляющее значение, которое вы хотите сравнить с получаемым значением, в даном случае это `0`. Также вы используете `default`, чтобы назначить действие, если оператор `switch` получит любое другое число, отличное от 0.

Вот другой пример использования `switch`:

    switch number {
    case 10:
      print(&quot;It's ten!&quot;)
    default:
      break
    }

В этом примере вы проверяете является ли значение переменной или константы равным 10, и, если это так, в консоли выводится соответствующее сообщение. Для значений, отличных от 10 никаких действий не предусмотрено. Когда вы не хотите выполнения какого-либо действия, или вы хотите определить дефолтное состояние для выполнения кода, можно использовать оператор `break`. Это подскажет Swift'у что вы не написали здесь никакго кода и никаких действий выполняться не будет. `сase` никогда не должен оставаться пустым, поэтому необходимо писать код, даже если этим кодом будет оператор `break`!

Оператор `switch` работает с любыми типами данных! Вот пример обработки для строк:

    let string = &quot;Dog&quot;

    switch string {
    case &quot;Cat&quot;, &quot;Dog&quot;:
      print(&quot;Animal is a house pet.&quot;)
    default:
      print(&quot;Animal is not a house pet.&quot;)
    }

После выполнения кода в консоле появится сообщение:

    Animal is a house pet.

В этом примере, вы передаете два значения для одного оператора `case`, поэтому код будет выполняться в случае, если переданое значение будет либо `&quot;Cat&quot;`, либо `&quot;Dog&quot;`.

### Продвинутые действия с оператором Switch

Вы можете также передать вашему оператору `switch` более, чем один `case`. В предыдущем разделе вы видели, что оператор `if` использует множество вложенных операторов `else-if` для конвертирования времени. Вы можете переписать это более кратко, с использванием оператора `switch`:

    let hourOfDay = 12
    var timeOfDay = &quot;&quot;

    switch hourOfDay {
    case 0, 1, 2, 3, 4, 5:
      timeOfDay = &quot;Early morning&quot;
    case 6, 7, 8, 9, 10, 11:
      timeOfDay = &quot;Morning&quot;
    case 12, 13, 14, 15, 16:
      timeOfDay = &quot;Afternoon&quot;
    case 17, 18, 19:
      timeOfDay = &quot;Evening&quot;
    case 20, 21, 22, 23:
      timeOfDay = &quot;Late evening&quot;
    default:
      timeOfDay = &quot;INVALID HOUR!&quot;
    }

    print(timeOfDay)

Выполнение этого кода выведет в консоль сообщение:

    Afternoon

Помните диапазоны? Вы можете использовать диапазоны в операторе `switch`. Можно переписать этот код еще более кратко:

    var timeOfDay2 = &quot;&quot;

    switch hourOfDay {
    case 0...5:
      timeOfDay2 = &quot;Early morning&quot;
    case 6...11:
      timeOfDay2 = &quot;Morning&quot;
    case 12...16:
      timeOfDay2 = &quot;Afternoon&quot;
    case 17...19:
      timeOfDay2 = &quot;Evening&quot;
    case 20..&lt;24:
      timeOfDay2 = &quot;Late evening&quot;
    default:
      timeOfDay2 = &quot;INVALID HOUR!&quot;
    }

    print(timeOfDay2)

Также можно сопоставлять условия, основанные на свойствах значения. Как вы узнали ранее в первой части этой серии, вы можете использовать оператор модуль для определения является ли целое число четным или нечетным. Например так:

    switch number {
    case let x where x % 2 == 0:
      print(&quot;Even&quot;)
    default:
      print(&quot;Odd&quot;)
    }

Выполнение этого кода выведет в консоль сообщение:

  Even

Оператор `switch` использует синаксис `let-where`, который означает, что `case` будет выполненен только если определенное условие будет выполняться как `true`. Часть синтаксиса `let` связывает значение и имя, в то время как оператор `where` обеспечивает булевое условие, которое должно выполняться как `true` для выполнения `case`. В этом примере  `case` выполняется в случае, если значение четное, т.е. если значение остатка от деления на 2 равно 0.

Этот метод, с помощью которого вы можете сравнивать числа еще называют паттерн сравнения.

В предыдущем примере была использована в общем-то ненужная константа `х`, фактически это еще одно наименование для `number`. Вы можете использовать `number` в конструкции `where`и заменить константу `х` на знак нижнего подчеркивания.

    switch number {
    case _ where number % 2 == 0:
      print(&quot;Even&quot;)
    default:
      print(&quot;Odd&quot;)
    }

### Частичное сравнивание

Другой способ, в котором вы можете очень эффективно использовать оператор `switch`для сравнения выглядит следующим образо:

    let coordinates = (x: 3, y: 2, z: 5)

    switch coordinates {
    case (0, 0, 0): // 1
      print(&quot;Origin&quot;)
    case (_, 0, 0): // 2
      print(&quot;On the x-axis.&quot;)
    case (0, _, 0): // 3
      print(&quot;On the y-axis.&quot;)
    case (0, 0, _): // 4
      print(&quot;On the z-axis.&quot;)
    default:        // 5
      print(&quot;Somewhere in space&quot;)
    }

Этот оператор `switch` использует частичное сравнивание. Вот что происходит в коде, по-порядку:

  1. Точное соответствие `case` в котором значение `(0, 0, 0)`. Это центр 3D координат.
  2. Совпадение y=0, z=0 и любое значение x. Это координата по оси х.
  3. Совпадение x=0, z=0 и любое значение y. Это координата по оси y.
  4. Совпадение x=0, y=0 и любое значение z. Это координата по оси z.
  5. Совпадение  с остальными координатами.

В данном примере используется знак нижнего подчеркивания потому, что нет особой необходимости в том, чтобы указывать наименование константы. Если же такая необходимость существует, то можно переписать код следующим образом.

    switch coordinates {
    case (0, 0, 0):
      print(&quot;Origin&quot;)
    case (let x, 0, 0):
      print(&quot;On the x-axis at x = \(x)&quot;)
    case (0, let y, 0):
      print(&quot;On the y-axis at y = \(y)&quot;)
    case (0, 0, let z):
      print(&quot;On the z-axis at z = \(z)&quot;)
    case let (x, y, z):
      print(&quot;Somewhere in space at x = \(x), y = \(y), z = \(z)&quot;)
    }

В данном случае используется синтаксис `let` для извлечения соответствующих значений. Затем в консоле выводится значение с помощью строковой интерполяции.

Обратите внимание на то, что в данном случае отсутствует дефолтное значение для оператора `switch`. Это потому, что последний `case` по сути является тем самым дефолтным значением. Он соответствуетлюбому значениям, которые не соответствуют предыдущим `case`ам. В `switch` нет необходимости в определении значения дефолтного `case`, если предусмотрены все возможные значения.

Также стоит обратить внимание на то, что правила синстаксиса позволяют указывать один оператор `let` для всех связанных значений кортежа: `let (x, y, z)` это то же самое, что `(let x, let y, let z)`.

Таким образом, можно, используя тот же самый синтаксис `let-where`, записать код с более комплексным решением, например так:

    switch coordinates {
    case let (x, y, _) where y == x:
      print(&quot;Along the y = x line.&quot;)
    case let (x, y, _) where y == x * x:
      print(&quot;Along the y = x^2 line.&quot;)
    default:
      break
    }

Как вы видите в данном случае сравнивается  &quot;y равный x&quot; и &quot;y равный квадрату x&quot;.

На этом мини-серия по Swift закончена. Желаем Вам успехов в изучении этого замечательного языка.

[Источник]({{page.source_url}})</content><author><name></name></author><category term="swift" /><category term="programming" /><summary type="html">Приветствуем вас в третьей части нашей мини-серии по Swift, в которой вы узнаете как использовать булевые пеерменные и управлять потоками. Данный материал является переводом tutorial с сайта raywenderlich.com.</summary></entry><entry><title type="html">NPM подсказки и советы для начинающих</title><link href="https://losthuman.ru/categories/code/2019/01/06/npm-sovety-i-trjuki.html" rel="alternate" type="text/html" title="NPM подсказки и советы для начинающих" /><published>2019-01-06T00:00:00+05:00</published><updated>2019-01-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/06/NPM-sovety-i-trjuki</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/06/npm-sovety-i-trjuki.html">Если вы ежедневно используете NPM в своей работе, то скорее всего вы по достоинству оцените эти подсказки и советы.

## Создание файла package.json

В этом случае мы обычно используем команду `npm init` и затем добавляем информацию, которую запрашивает npm. Но, если в некоторых случаях нет никакой необходимости заботиться о том, какая информация будет в файле package.json и возможно использовать дефолтные значения для проекта, то мы просто нажимаем enter вместо того, чтобы отвечать на вопросы npm. Чтобы не терять время на это можно просто добавить `-y` или `--yes` к команде `npm init`. В этом случае package.json будет создан с дефолтными настройками без дополнительных вопросов.


## Установка модулей

Вместо `npm install` можно использовать упрощенный вариант `npm i`.

## Установка нескольких модулей за один раз

Вместо использования команды `npm install` для каждого модуля, как например:    
    
    npm i gulp-pug  
    npm i gulp-debug  
    npm i gulp-sass

Можно одной командой инсталировать все модули сразу:
    
    
    npm i gulp-pug gulp-debug gulp-sass

Еще проще сожно установить нескольуо модулей за один раз, если их названия начинаются с одного и того же сочетания букв:

    npm i gulp{-debug,-sass,-pug}

## Использования установочных флагов

Если вы хотите установить пакет и сохранить его в production зависимостях, то обычно это делается следующим образом:

    npm i gulp --save-prod

Но, также можно использовать флаг  `-P`:
    
    
    npm i gulp -P

То же самое справедливо для development зависимостей, вместо `--save-dev` можно использовать флаг `-D`:
    
    
    npm i gulp -D

По умолчанию, когда вы запускаете команду `npm install` без флагов, npm добавит устанавливаемый пакет в зависимости вашего файла package.json. Если вы хотите предотвратить это, то используйте флаг `--no-save` при установке такого пакета:
    
    
    npm i vue --no-save

## Информация о пакетах

Следующие команды покажут вам информацию относящуюся к пакету vue:

`npm view vue` или `npm v vue`

![]({{page.images_url}}2.png)Результат выполнения комманды npm view

В случае, если вы хотите получить только последнюю версию пакета можно использовать команду:    
    
    &gt; npm v vue version  
    &gt; 2.5.17

Если вы захотите получить полный список версий пакета, используйте ту же команду, только во множественном числе:
    
    &gt; npm v vue versions  
    &gt; [ '0.0.0',  
      '0.6.0',  
      '0.7.0',  
      ...  
      '2.5.15',  
      '2.5.16',  
      '2.5.17-beta.0',  
      '2.5.17' ]

## Установка определенной версии пакета

Если необходимо установить определенную версию пакета, которая не является последней, вы можете использовать команду:    
    
    npm i vue@2.5.15


Иногда легче запомнить имя, чем номер, поэтому вы можете использовать dist-теги, перечисленные после выполнения команды `npm v`, как показано на выше, вот так:
    
    npm i vue@beta

 **Searching for a package**

Иногда вы не можете просто запомнить пакета, который вы использовали в проектах некоторое время назад. В этом случае можно выполнить поиск прямо из терминала, например так:
    
    
    npm search gulp debug

or
    
    npm s gulp debug

После выполнения этих команд в терминале будет напечатан список пакетовс оприсанием, указанием авторов и другой информацией.

![]({{page.images_url}}3.png) Результат поиска

## Удаление пакетов

Если вы не хотите открывать файл package.json и удалять зависисомтси вручную, можно сделать это с помощью команды:    
    
    npm uninstall vue

Эта команда удалит пакет из папки node_modules и из файла package.json. Конечно в данном случае можно использовать команды `rm` , `un` или `r`, чтобы достичь такого же результата:    
    
    npm rm vue

Если по каким-то причинам вы хотите удалить файлы пакет из папки node_modules, но при этом сохранитьего в чписке зависимостей в файле package.json можете использовать для этого флаг no-save:    
    
    npm rm vue --no-save

 **Listing dependencies**

Для того, чтобы посмотреть список всех зависимостей в вашем проекте, используйте комманду:    
    
    npm ls

Эта команда выведет в терминале список всех зависимостей из файла package.json, а также **всех их зависимостей**. если вы хотите получить список только ваших зависисомтей, то воспользуйтесь командой:
    
    
    npm ls --depth=0

После выполнения этой команды вы получите что-то подобное:
    
    ├── jquery@3.3.1  
    ├── vue@2.5.17  
    └── yarn@1.12.3

Конечно, вы можете исполььзовать флаг `g`, если вы хотите получить список всех ваших глобально установленных пакетов:
    
    
    npm ls -g -depth 0

## Запуск тестов

Тесты можно запускать с помощью комманды `npm run tests`, но можно проще - `npm test` или еще проще -  `npm t`.

## Показать доступные скрипты

Иногда мы хотим посмотреть какие скрипты включены в файл package.json. Можно открыть файл package.json, конечно, но можно также запустить команду:    
    
    npm run

Если конфигурация в в файле package.json например выглядит так:
    
    &quot;scripts&quot;: {  
      &quot;test&quot;: &quot;jest&quot;,  
      &quot;build&quot;: &quot;gulp build&quot;  
    }

То после выполнения команды `npm run` мы получим:
    
    Lifecycle scripts included in npm:  
      test  
        jest
    
    
    available via `npm run-script`:  
      build  
        gulp-build


## Установка пакетов из репозитария GitHub

Вы можете также устанавливать пакеты прямо из репозитария GitHub:    
    
    npm i &lt;https://github.com/sindresorhus/gulp-debug&gt;

Или можно опустить доменную часть
    
    npm i sindresorhus/gulp-debug


## Открытие Github страницы пакета

Можно конечно поискать страницу пакета в Google, а можно запустить следующую команду в терминале:    
    
    npm repo create-react-app


Пакет не должен быть установлен во время выполнения этой команды.


## Список всех доступных переменных среды NPM 


Вы можете увидеть полный список всех переменных NPM, которые доступны:    
    
    npm run env | grep npm_

После выполнения этой команды в терминале отобразится нечто подобное:

    npm_config_fetch_retry_maxtimeout=60000  
    npm_config_tag_version_prefix=v  
    npm_config_strict_ssl=true  
    npm_config_sso_type=oauth  
    .  
    .  
    .

Это очень полезная вещь, так как зная обо всех переменных которые вам доступны вы можете не только их использовать, но и создавать свои собственные.


## Добавление собственных NPM перерменных

Вы можете добавлять свои собственные NPM переменные, добавляя новые ключи в файл package.json. Это богут быть любые ключи, но возможно также хранить все ваши NPM переменные внутри ключа `config`, просто в целях лучшей организации. Например так:    
    
    &quot;config&quot;: {
    
    
      &quot;build_folder&quot;:&quot;./dist&quot;
    
    
    }

Если после добавления вашей собственной переменоой выполнить команду `npm run
env | grep npm_`, вы увидите среди других переменных свою собственную:
    
    npm_package_config_build_folder=./dist  
    npm_config_fetch_retry_maxtimeout=60000  
    npm_config_tag_version_prefix=v  
    npm_config_strict_ssl=true  
    npm_config_sso_type=oauth  
    .  
    .  
    .

По умолчанию npm будет присваивать переменным префиксы `npm_package` сохраняя таким образом структуру внутри файла package.json.


## использование NPM переменной в NPM скрипте

Предположим, что вы увидели полный список переменных и захотели использовать значения любых из них в вашем скрипте. Вы можете сделать это в вашем файле package.json:
    
    &quot;scripts&quot;: {
    
    
      &quot;build&quot;: &quot;gulp build --dist $npm_package_config_build_folder&quot;
    
    
    }

После запуска команды `npm run build` она будет выполнена как:    
    
    gulp build --dist ./dist

Вот и все!


[Источник]({{page.source_url}})</content><author><name></name></author><category term="npm" /><category term="nodejs" /><summary type="html">Если вы ежедневно используете NPM в своей работе, то скорее всего вы по достоинству оцените эти подсказки и советы.</summary></entry><entry><title type="html">Uber тестирует сервис предоставления работников во временное пользование</title><link href="https://losthuman.ru/categories/technews/2018/10/19/uber-testiruet-servis-predostavlenija-rabotnikov-vo.html" rel="alternate" type="text/html" title="Uber тестирует сервис предоставления работников во временное пользование" /><published>2018-10-19T00:00:00+05:00</published><updated>2018-10-19T00:00:00+05:00</updated><id>https://losthuman.ru/categories/technews/2018/10/19/Uber-testiruet-servis-predostavlenija-rabotnikov-vo</id><content type="html" xml:base="https://losthuman.ru/categories/technews/2018/10/19/uber-testiruet-servis-predostavlenija-rabotnikov-vo.html">По информации [cnet.com]({{page.source_url}}) компания Uber демонстрирует все признаки еще более глубокого погружения в гик-экономику.

Компания по сообщениям тестирует расширение своей бизнес-модели, которая в настоящий момент сосредоточена в основном вокруг предоставления услуг краткосрочной аренды автомобилей с водителями, велосипедов и скутеров.  Предполагается, что пилотная программа под названием Uber Works, будет предлагать по требованию временных работников, таких как официанты и охранники, для различных мероприятий.

Uber работает над этим проектом в течение последних нескольких месяцев в Чикаго и ранее экспериментировал с ним в Лос-Анджелесе. Управляться новый сервис будет по модели уже созданного сервиса UberEats (служба доставки еды).</content><author><name></name></author><category term="uber" /><summary type="html">По информации cnet.com компания Uber демонстрирует все признаки еще более глубокого погружения в гик-экономику.</summary></entry><entry><title type="html">Swift: Типы и операции. Часть 2</title><link href="https://losthuman.ru/categories/code/2018/10/07/swift-tipy-i-operatsii-chast-2.html" rel="alternate" type="text/html" title="Swift: Типы и операции. Часть 2" /><published>2018-10-07T00:00:00+05:00</published><updated>2018-10-07T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2018/10/07/Swift-Tipy-i-operatsii-Chast-2</id><content type="html" xml:base="https://losthuman.ru/categories/code/2018/10/07/swift-tipy-i-operatsii-chast-2.html">Добро пожаловать во вторую часть мини-серии по изучению языка программирования Swift, в которой вы познакомитесь  со строками, преобразованием типов и кортежами. Данный материал является переводом [tutorial]({{page.source_url}}) с сайта [raywenderlich.com](https://www.raywenderlich.com).

Эта часть является продолжением [Swift: выражения, переменные и константы. Часть 1](https://losthuman.ru/blog/code/2018/10/06/swift-uchebnik-chast-1-vyrazhenija.html). Мы рекомендуем Вам начать с первой части, чтобы не пропустить и не потерять.

Пришло время более подробно поговорить про типы! Формально, тип описывает набор значений и операций, которые могут быть выполнены с ним.

В этом учебном пособии вы научитесь работаь с различными типами которые есть в Swift. Вы научитесь конвертировать типы один в другой, а также познакомитесь с выводом типа, который сделает вашу жизнь как программиста намного проще.

В конце вы познакомитесь с кортежами (tuples), которые позволяют создавать собственные множественные значения любого типа.

### С чего начать

Иногда вы будете получать данные в одном формате и нуждаться в том, чтобы конвертировать их в другой формат. Наивно пытаться решить эту задачу следующим образом:

    var integer: Int = 100
    var decimal: Double = 12.5
    integer = decimal

Компилятор Swift будет жаловаться, если вы попытаетесь это сделать и выдаст ошибку на третьей строке:

    'Cannot assign value of type 'Double' to type 'Int'`

Некоторые языки программирования не так строги в отношении типов и будут выполнять такие преобразования автоматически. Опыт показывает, что такое автоматическое преобразование является источником ошибок программного обеспечения, и это часто ухудшает производительность. Swift предотвращает появление в коде присвоения значения одного типа другому, и это позволяет избежать этих проблем.

Помните, что компьютеры полагаются на программистов, в том, что касается постановки задач и способов их решения. В Swift для исключения возможности появления ошибок включено явное преобразование типов. Если вы хотите чтобы преобразование произощло, вы должны это объявить!

Вместо простого назначения вам нужно явно указать, что вы хотите преобразовать тип. Вы делаете это так:

    var integer: Int = 100
    var decimal: Double = 12.5
    integer = Int(decimal)

Присвоение в третьей строке кода теперь говорит Swift'у недвусмысленно, что вы хотите преобразовать переменную типа `Double` в новый тип `Int`.

Примечание. В этом случае назначение десятичного значения целому числу приводит к потере точности: переменная `integer` заканчивается значением `12` вместо `12,5`. Вот почему важно в данном случае конвертировать типы явным образом. Swift хочет убедиться что вы знаете, что делаете, и что вы понимаете, что таким образом можете потерять данные выполняя преобразование типа.

#### Операции с разными типами

Не так давно вы изучили числа и производили операции отдельно с целыми, отдельно с десятичными числами. Но, что если у вас будет целое число и вы захотите умножить его на десятичное?

Вы может быть думает, что сможете сделать так:

    let hourlyRate: Double = 19.5
    let hoursWorked: Int = 10
    let totalCost: Double = hourlyRate * hoursWorked

Если вы попытаетсь это сделать, вы получите ошибку в последней строке:

    `Binary operator '*' cannot be applied to operands
    of type 'Double' and 'Int'`

Эта шибка появилась потому, что в Swift вы не можете использовать оператор `*` для различных типов данных. Это правило также верно и для других арифметических операторов. На первый взгляд это может показаться удивительным, но Swift делает это прежде всего, чтобы вам помочь.

Swift заставляет вас быть явным в вопросе, касающемся того, понимаете ли вы что делаете, когда умножатете переменную типа `Int` на переменую типа `Double`, потому, что результатом такой операции может быть только _один_ тип. Хотите, чтобы результатом умножения был `Int` - конвертируйте `Double` в `Int`, до того, как выполнится умножение. Хотите, чтобы результатом операции был `Double` - конвертируйте `Int` в `Double` до выполнения операции умножения.

В этом примере вы хотите. чтобы результат имел тип `Double`. Вы не хотите, чтобы результатом был `Int`, потому что в этом случае Swift преобразует константу `hourlyRate` в `Int`, чтобы выполнить умножение, округляя ее до 19 и теряя точность `Double`.

Для этого вам нужно сказать Swift, что вы хотите, чтобы он считал константу `hoursWorked` `Double`:

    let hourlyRate: Double = 19.5
    let hoursWorked: Int = 10
    let totalCost: Double = hourlyRate * Double(hoursWorked)

В результате каждый операнд будет иметь тип `Double` когда Swift пермножит их, таким образом константа `totalCost` будет иметь тип `Double`.

####  Вывод типа

До настоящего места в этом уроке вы видели, что переменная или константа всегда объявлялись с указанием соответствующего типа, как например в следующем примере:

    let integer: Int = 42
    let double: Double = 3.14159

Вы можете спросить себя: &quot;Почему я должен всегда писать `: Int` и `: Double`, когда в правой части выражения _также есть_ `Int` или `Double`&quot;? Такая избыточность нужна для дополнительной страховки. Вы скоро сможете убедиться, что это можно и не делать.

Оказывается, компилятор Swift также может это сделать за вас (указать тип переменной ли константы). Вовсе не нужно, чтобы вы все время указывали типы - компилятор может разобраться с типами самостоятельно. Эта работа выполняется благодаря процессу, называемому выводом типа. Не все языки программирования имеют такую способность, но Swift это может, и это ключевой компонент мощи Swift как языка.

Поэтому вы можете просто удалить тип данных в большинстве мест кода, где вы его видите.

Например, рассмотрим следующее объявление константы:

    let typeInferredInt = 42

Иногда полезно проверять предполагаемый тип переменной или константы. Вы можете сделать это в playground, удерживая клавишу `Option` и нажав имя переменной или константы. Xcode отобразит следующее:

[![Inferred Int](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-int-1.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-int-1.png)

Xcode сообщает вам вывод типа предоставляя вам декларацию о том, что вы
bcgjkmpetnt, если не было вывода типа. В этом случае тип `Int`.

Это же справедливо и для других типов::

    let typeInferredDouble = 3.14159

Клик по этому параметру показывает следующее:

[![Inferred Double](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-double-1.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-double-1.png)

Вывод типа не является чем-то магическим. Swift просто делает то, что без труда делает ваш мозг. Языки программирования, которые не используют вывод типа, часто требуют большей &quot;многословности&quot; при написании кода, потому что вам нужно указывать явно тип каждый раз, когда вы объявляете переменную или константу.

Иногда вы хотите определить константу или переменную и убедиться, что это определенный тип, хотя то, что вы назначаете ему, является другим типом. Вы видели раньше, как вы можете конвертировать один тип в другой. Например, рассмотрим следующее:

    let wantADouble = 3

Здесь Swift указывает тип `wantADouble` как `Int`. Но что, если вы хотите вместо этого `Double`?

Вы можете сделать следующее:

    let actuallyDouble = Double(3)

Это тоже самое, что вы делали раньше для конвертации типов.

Другая опция может быть не пользуется выводом типа вовсе и работает следующим образом:

    let actuallyDouble: Double = 3

Есть еще третий способ:

    let actuallyDouble = 3 as Double

Здесь используется нновый оператор, которого вы раньше не видели. `as`, также выполняет конвертацию типа.

Вообще говоря, символ `3` сам по себе не имеет типа. Это только при использовании в выражении или присваивая этот символ константе или переменной, Swift назначает тип.

&gt;Примечание: Буквенные значения не имеют типа. Только при использовании их в
выражениях или присвоения их константе или переменной, для которых Swift требует определить тип.

Также может использоваться литеральное числовое значение, которое не содержит десятичной точки как `Int` и как `Double`. Вот почему вам разрешено присваивать значение  `3` константе `actuallyDouble`.

Значения литеральных чисел, которые содержат десятичную точку, не могут быть целыми числами.

Это означает, что вы могли бы избежать всего этого обсуждения, если бы написали:

    `let wantADouble = 3.0`

### Строки

Числа важны для программирования, но они не являются единственным типом данных с которым ужно работать в ваших приложениях. Текст также является чрезвычайно распространенным типом, например, имена людей, их адреса или даже слова книги. Все это - примеры текста, которые может потребоваться для приложения.

Большинство языков компьютерного программирования хранят текст в типе данных, называемом строкой (`string`). Эта часть урока познакомит вас со строками, сначала дав вам общую информацию о концепции строк, а затем, покажет вам, как их использовать в Swift.

#### Как компьютер представляет строки

Компьютеры думают о строках как о наборе отдельных элементов. Весь код, на любом языке программирования, можно сократить до необработанных чисел. Строки также подпадают под данное правило.

Это может показаться странным. Как символы могут быть числами? В его основе лежит необходимость дать компьютеру  возможность переводить человеческие буквы и цифры в собственный компьютер язык, и он делает это, назначая каждому элементу другое число. Эта система образует двухстороннее сопоставление от символа к числу, и наоборот.

[![Unicode comic](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-unicode-comic-650x406.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-unicode-comic.png)

Когда вы нажимаете клавишу на клавиатуре, вы на самом деле передаете номер определенного элемента (буквы) в компьютер. Ваш текстовый процессор (приложение) преобразует это число в изображение элемента (буквы) и, наконец, представляет вам результат преобразования на экране монитора.

### Unicode

В сущности компьютер абстрактно свободен в выборе любого символьного набора. Если компьютер хочет, чтобы буква а равнялась числу 10, тогда это так и может быть. Но когда компьютеры начинают разговаривать друг с другом, им необходимо использовать общий набор символов. Если на двух компьютерах используются разные наборы символов, тогда, когда один компьютер передал строку другому, получится в конечном итоге что строки содержат разные символы.

Было несколько популярных стандартов, но самым современным стандартом является Unicode. Он определяет отображение набора символов, которое используют почти все компьютеры сегодня.

&gt;Примечание: Вы можете прочитать больше об Unicode на [официальном сайте](http://unicode.org)

Рассмотрим слово cafe. Стандарт Unicode говорит нам, что буквы этого слова должны быть закодированы цифрами следующим образом:

![cafe](https://koenig-media.raywenderlich.com/uploads/2016/09/cafe-1.png)

Число, связанное с каждым символом, называется кодовой точкой. Итак, в
пример выше, `c` использует кодовую точку 99, `a` использует кодовую точку 97 и так далее.

Конечно, Unicode предназначен не только для простых латинских символов, используемых в английском языке, например, c, a, f и e. Он также позволяет вам отображать символы из языков во всем мире. Слово кафе происходит от французского, в котором написано как cafe. Unicode отображает эти символы так:

![cafe_with_accent](https://koenig-media.raywenderlich.com/uploads/2016/09/cafe_with_accent.png)

И вот пример использования китайских иероглифов (это, согласно Google переводчику, означает &quot;Computer Programming&quot;):

![computer_programming_chinese](https://koenig-media.raywenderlich.com/uploads/2016/09/computer_programming_chinese-650x164.png)

Вы, наверное, слышали об эмодзи, которые представляют собой небольшие картинки, которые вы можете использовать в вашем тексте. Эти картинки, по сути, являются просто обычными буквами, также отображаемыми Unicode. Например:

![poo_face](https://koenig-media.raywenderlich.com/uploads/2016/09/poo_face.png)

Это всего два символа. Кодовые точки для них очень большие числа, но каждая из них по-прежнему остается только одной кодовой точкой. Компьютер считает они ничем не отличаются от любых других двух символов.

&gt;Примечание: слово «emoji» происходит от японского: «e» означает изображение, а «moji» означает буквы.

### Строки в Swift

Swift, как и любой хороший язык программирования, может работать непосредственно и с буквами, и со строками. Он делает это через типы данных `Character` и `String`, соответственно. В этом разделе вы узнаете об этих типах данных и о том, как работать с ними.

#### Characters and Strings

`Character` это тип данных, экземпляр которого может хранить одну букву (один символ). Например:

    let characterA: Character = &quot;a&quot;

Таким способом хранится буква `а`. Точно также мохно хранить любой символ, даже эмодзи:

    let characterDog: Character = &quot;🐶&quot;

Но этот тип данных разработан для хранения только одного символа. А вот тип `String` может хранить несколько символов. Например:

    let stringDog: String = &quot;Dog&quot;

Правая сторона этого выражения представляет собой то, что известно под названием строковый литерал. Это синтаксис Swift для представления строк.

Конечно, вывод типа применяется по отношению к строкам также, как к числам. Если вы удалите тип из объявления константы `stringDog` тогда Swift справедливо назначит этой константе тип `String`.

    let stringDog = &quot;Dog&quot; // Inferred to be of type String

&gt;Примечание: В Swift нет такого понятия, как символьный литерал. Символ представляется строкой с длинной равной единице. Однако Swift указывает тип любой строки литералом `String`, поэтому, если вы хотите вместо этого получить тип `Character`, вы должны явно назначить этот тип.

#### Конкатенация строк

Вы можете делать гораздо больше, чем создавать простые строки. Иногда вам нужно
манипулировать строкой, и один из общих способ сделать это - объединить ее с другими строками.

В Swift это делается довольно просто: с помощью оператора сложения. Так же, как вы можете сложить числа, вы можете сложить строки:

    var message = &quot;Hello&quot; + &quot; my name is &quot;
    let name = &quot;Lorenzo&quot;
    message += name // &quot;Hello my name is Lorenzo&quot;

Вам нужно объявить `message` как переменную, а не константу, потому что вы хотите изменить ее. Вы можете добавить строковые литералы сразу вместе, как в первой строке, но также вы можете добавить строковые переменные или константы так, как это сделано в последней строке.

Также возможно добавить символы в строку. Однако строгая типизация Swift означает, что типы должны быть явными, так же, точно так же как это было показано на примере чисел.

Чтобы добавить символ в строку, можно сделать следующее:

    let exclamationMark: Character = &quot;!&quot;
    message += String(exclamationMark) // &quot;Hello my name is Lorenzo!&quot;

С помощью этого кода вы явно преобразуете `Character` в строку `String` до того, как добавите его в `message`.

#### Интерполяция строк

Вы также можете создать строку, используя интерполяцию, которая является специальным cинтаксисом Swift и позволяет создавать строку таким способом, который легко читать:

    let name = &quot;Lorenzo&quot;
    let messageInOne = &quot;Hello my name is \(name)!&quot; // &quot;Hello my name is Lorenzo!&quot;

Такой код читается гораздо легче, чем пример из предыдущего раздела.
Это расширение синтаксиса строкового литерала, посредством которого вы заменяете определенные части строки другими значениями.

Такой синтаксис работает точно так же, как построение строк из других типов, таких как числа:

    let oneThird = 1.0 / 3.0
    let oneThirdLongString = &quot;One third is \(oneThird) as a decimal.&quot;

В данном примере вы добавляете в строку константу `Double` способом интерполяции. В результатае последняя строка кода - константа `oneThirdLongString` будет содержать следующее:

    One third is 0.3333333333333333 as a decimal.

Разумеется, на самом деле длинна `oneThird` практически бесконечна, потому что это повторяющееся десятичное число. Строчная интерполяция с помощью `Double` не дает возможности контролировать точность получаемой строки.

Это следствие использования интерполяции строк - просто для использования, но не дает возможности настраивать вывод. Имейте это ввиду.

#### Многострочные строки

У Swift есть удобный способ представления многострочных строк. Это может быть весьма полезным, когда вам нужно поместить очень длинную строку в свой код.

Делается это так:

    let bigString = &quot;&quot;&quot;
        Вы можете создавать строки  
        которые имеют несколько  
        строк  
        делая это
        таким способом.
        &quot;&quot;&quot;
    print(bigString)

Три двойные кавычки означают, что это многострочная строка. Первая и последняя строки кода не становятся частью строки. Это делает его более гибким.

В приведенном выше примере будет напечатано следующее:

    Вы можете создавать строки  
    которые имеют несколько  
    строк  
    делая это
    таким способом.

### Кортежи (Tuples)

Иногда данные формируются парами или тройками. Примером этого является пара (x, y) в двумерной сетке. Аналогично, набор координат в трехмерной сетке состоит из значения x, y-значения и z-значения.

В Swift вы можете представлять такие связанные данные очень простым способом через использование кортежа.

Кортеж - это тип, который представляет данные, состоящие из более чем одного значения любого типа. Вы можете иметь столько значений в кортеже, сколько захотите. Например, вы может определять пару двумерных координат, где каждое значение оси представляет собой целое число, вот так:

    let coordinates: (Int, Int) = (2, 3)

Тип `coordinates` - это кортеж, содержащий два значения `Int`. Типы значений внутри кортежа, в этом случае `Int`, разделяются запятыми окруженный круглыми скобками. Код для создания кортежа - тое же, с каждым значением, разделенным запятыми и окруженным скобками.

Вывод типа может также определять типы кортежей:

    let coordinatesInferred = (2, 3) // вывод типа (Int, Int)

Таким же образом можно создать кортеж, состоящий из знчений `Double`:

    let coordinatesDoubles = (2.1, 3.5) // Вывод типа (Double, Double)

Или вы можете включать в кортеж различные типы:

    let coordinatesMixed = (2.1, 3) // Вывод типа (Double, Int)

А вот как происходит доступ к данным внутри кортежа:

    let coordinates = (2, 3)
    let x1 = coordinates.0
    let y1 = coordinates.1

Вы можете получить каждый элемент в кортеже по его индексу в кортеже, начиная с нуля. Итак, в этом примере `x1` будет равен `2`, а `y1` будет равен `3`.

&gt;Примечание: Начало отстчета с нуля, это обычная практика в программировании и называется нулевой индексацией.

В предыдущем примере может быть не сразу очевидно, что первое значение в индексе `0` - это координата x, а второе значение - по индексу `1`, является y-координатой. Это еще одна демонстрация того, почему важно всегда называть переменные таким образом, чтобы избежать путаницы.

К счастью, Swift позволяет вам называть отдельные части кортежа, и вы можете явно указать на то, что представляет каждая часть. Например:

    let coordinatesNamed = (x: 2, y: 3) 
    // Вывод типа (x: Int, y: Int)

В коде аннотированы значения `coordinatesNamed`, содержащий метку для каждой части кортежа. Затем, когда вам нужно получить доступ к каждой части кортежа, вы сможете получить к ней доступ через имя соответствующего элемента кортежа:

    let x2 = coordinatesNamed.x
    let y2 = coordinatesNamed.y

Это гораздо понятнее. Полезно именовать компоненты ваших кортежей.

Если вы хотите получить доступ к нескольким частям кортежа одновременно, как в примере выше, вы также можете использовать сокращенный синтаксис, упрощающий доступ к элементам кортежа:

    let coordinates3D = (x: 2, y: 3, z: 1)
    let (x3, y3, z3) = coordinates3D

Объявлене трех новых констант: `x3`, `y3` и `z3` и присваивание каждую часть
кортежа соответствующим константам. Код эквивалентен следующему:

    let coordinates3D = (x: 2, y: 3, z: 1)
    let x3 = coordinates3D.x
    let y3 = coordinates3D.y
    let z3 = coordinates3D.z

Если вы хотите игнорировать определенный элемент кортежа, вы можете заменить соответствующую часть декларации нижним дефисом. Например, если вы выполняли 2D-расчет и хотели игнорировать z-координату `coord3D`, то вы должны написать следующее:

    let (x4, y4, _) = coordinates3D

Эта строка кода объявляет только `x4` и `y4`. `_` является особым знаком и означает, что вы сейчас игнорируете эту часть.

&gt;Примечание: Вы увидите, что вы можете использовать символ нижнего дефиса - также называемый оператором подстановочного знака - во всем Swift, чтобы игнорировать значение.

### Числовые типы

Вы используете `Int` для представления целых чисел. `Int` представлен 64-битным на большинстве современных аппаратных средств и 32-битным на устаревших или имеющих ограниченные ресурсы. На самом деле Swift предоставляет гораздо больше числовых типов, которые используют разные объемы памяти для хранения значений. Для целых чисел вы можете использовать явное объявление типов `Int8`,`Int16`, `Int32` и `Int64`. Эти типы занимают 1, 2, 4 и 8 байтов памяти, соответственно. Каждый из этих типов использует 1 бит для хранения одного знака.

Если вы имеете дело только с неотрицательными значениями, существует набор явных
беззнаковые типов, которые вы можете использовать. К ним относятся `UInt8`, `UInt16`, `UInt32` и `UInt64`.

Ниже приведен краткий обзор различных целых типов и размеров памяти, необходимой для их хранения. В большинстве случаев вы захотите использовать `Int`. Другие числовые типы как правило становятся полезными в приложении, если ваш код взаимодействует с другим программным обеспечением, которое использует один из этих более точных типов, или если вам нужно оптимизировать для хранения размер данных.

![int_sizes](https://koenig-media.raywenderlich.com/uploads/2016/09/int_sizes-650x274.png)

Вы использовали `Double` для представления дробных чисел. Swift предлагает `Float`, который имеет меньше разрядов и точность чем `Double`, но требует вдвое меньше места для хранения. Современное аппаратное обеспечение как правило  оптимизировано для `Double`, поэтому `Double` это тот тип, который следует использовать, если, вы хотите получить максимальную точность десятичного числа.

![float_sizes](https://koenig-media.raywenderlich.com/uploads/2016/09/float_sizes-650x91.png)

В большинстве случаев вы будете использовать `Int` и `Double` для представления чисел, но время от времени, вы можете столкнуться с другими типами. Вы уже знаете как с ними бороться. Например, предположим, что необходимо сложить `INT16` с `uint8` и `int32`. Вы можете сделать это следующим образом:

    let a: Int16 = 12
    let b: UInt8 = 255
    let c: Int32 = -100000

    let answer = Int(a) + Int(b) + Int(c) // Answer is an Int

### Взгляд за кулисы: протоколы

Несмотря на то, что существует десяток различных числовых типов, их довольно легко понять и использовать. Это потому, что все они поддерживают примерно одни и те же операции. Другими словами, если вы знаете, как использовать `Int`, использовать любой другой из числовых типов будет очень просто.

Одной из поистине замечательных особенностей Swift является то, как он формализует идею общности типов, используя то, что называют протоколами. Изучая протокол, вы мгновенно поймете, как целое семейство типов, которые используют этот протокол работают.

В случае целых чисел, этот принцип представлен на диаграмме:

[![Integer Protocols](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-integer-protocols-650x459.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-integer-protocols.png)

Стрелки указывают на соответствие (иногда называемое _адоптация_) протоколу. Не смотря на то, что этот график не показывает все протоколы, которым соответствуют  целочисленные типы, это дает вам представление о том, как все организовано.

Swift является первым языком, созданным на основе протоколов. Когда вы начнете понимать протоколы, которым соответствую типы, вы можете начать использовать эту систему способами невозможными в других языках.

### Что дальше?

Вы можете загрузить финальный [файл playground](https://koenig-media.raywenderlich.com/uploads/2018/09/Swift-Tutorial-Part-2.zip). Там же  вы найдете мини-упражнения для выполнения. Если вы застряли или вам нужна помощь, не стесняйтесь воспользоваться сопутствующими решениями.

В этом уроке вы узнали, что типы являются фундаментальной частью программирования. Это то, что позволяет правильно хранить данные. Кроме этого вы познакомились со строками и кортежами, а также кучей числовых типов.

В следующей части вы узнаете о Булевой логике и простом управлении потоком передачи данных.</content><author><name></name></author><category term="swift" /><category term="programming" /><summary type="html">Добро пожаловать во вторую часть мини-серии по изучению языка программирования Swift, в которой вы познакомитесь со строками, преобразованием типов и кортежами. Данный материал является переводом tutorial с сайта raywenderlich.com.</summary></entry><entry><title type="html">Swift: выражения, переменные и константы. Часть 1</title><link href="https://losthuman.ru/categories/code/2018/10/06/swift-uchebnik-chast-1-vyrazhenija.html" rel="alternate" type="text/html" title="Swift: выражения, переменные и константы. Часть 1" /><published>2018-10-06T00:00:00+05:00</published><updated>2018-10-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2018/10/06/Swift-uchebnik-Chast-1-vyrazhenija</id><content type="html" xml:base="https://losthuman.ru/categories/code/2018/10/06/swift-uchebnik-chast-1-vyrazhenija.html">Добро пожаловать в мини-серию о начале программирования на языке Swift! В
в этой серии вы узнаете основы программирования на Swift. Данный материал является переводом [tutorial]({{page.source_url}}) с сайта [raywenderlich.com](https://www.raywenderlich.com).

В этой серии вы познакомитесь с  основами программирования в современной, дружественной среде на языке программирования Swift.

Вместо того, чтобы утомлять теорией, сразу же перейдем к кодированию
с помощью Swift, используя Swift Playground - специальную среду разработки для тестирования отдельных фрагментов кода, в которой вы можете выполнять код напрямую без необходимости создавать полноценное приложение.

Для этого урока вам понадобится Xcode 10, стандартная среда разработки
для macOS [доступна здесь](https://developer.apple.com/xcode/). Если у вас
Xcode версии 9 или ниже, некоторые фрагменты кода в этом руководстве не будет работать так, как ожидается.

### С чего начать

Набор инструментов, которые используются для написания программного обеспечения, часто называют цепь инструментов. Часть цепочки инструментов, в которую вы пишете код, известна как интегрированная среда разработки (IDE). Xcode-это IDE, которая включает playground.

Вы будете использовать playgrounds во всей этой серии, чтобы практиковать кодирование, так что важно понимать, как playground работает. Вот что вы изучите в остальной части этого руководства.


### Создание Playground

Когда вы откроете Xcode, первое, что вы увидете будет окно приветствия:

[![Welcome to Xcode](https://koenig-media.raywenderlich.com/uploads/2018/08/swift-tutorial-part-1-welcome-650x381.png)](https://koenig-media.raywenderlich.com/uploads/2018/08/swift-tutorial-part-1-welcome.png)

Если вы не видите этот экран, это скорее всего потому, что в чекбоксе, расположенном в нижнем левом углу окна при пердыдущем запуске Xcode был была снят флажок. Вы также можете открыть экран нажатие клавиши `Command-Shift-1`. Вы также можете нажать `Window ▸ Welcome to Xcode` в меню.

На экране приветствия вы можете быстро перейти в playground, нажав на `Get started with a playground`. После чего Xcode представит вам возможность выбора шаблона.

[![Template](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-template-590x500.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-template.png)

Выбранная платформа определяет, какая версия шаблона Xcode будет использоваться для создания файла playground. В нашем примере можно выбрать: iOS, macOS или
tvOS. Каждая платформа имеет свою собственную среду и готова для операций с кодом в playground. Для целей данного руководства, выберите  шаблон `Blank` и нажмите `Next`. 

Теперь Xcode попросит вас указать наименование файла playground и выбрать место для его сохранения. Название может быть любое поэтому, когда вы создаете свои файлы playground, не стесняйтесь выбирать правильные имена  - это поможет вам в будущем вспомнить, какой код в том или ином файле playground.

Нажмите `Create`, чтобы создать и сохранить файл playground. Xcode создаст файл:

[![Create](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-create-1-650x442.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-create-1.png)

Новые файлы playground не создаются полностью пустым, даже, если для их создания используется шаблон `Blank`, они имеют базовый код. Не волнуйтесь - вы скоро узнаете, что означает этот код.

#### Обзор Playground

На первый взгляд, может показаться, что playground выглядит как необычный текстовый редактор. Что ж, на самом деле это так и есть! Почти.

[![Overview](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-overview-650x435.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-overview.png)

На скриншоте выше показаны первые и самые важные вещи, которые нужно знать работая в редакторе playground:

1. `Source editor` (редактора исходного кода): это область, в которой вы будете писать код  на Swift. Это похоже на текстовый редактор, такой как «Блокнот» или «TextEdit». Вы заметите, что он использует так называемый моноширинный шрифт, что означает, что все символы имеют одинаковую ширину. Это упрощает чтение и форматирование кода.
  
2. `Results sidebar` (боковая панель результатов): Эта область показывает результаты при выполнении кода. Вы узнаете больше о том, как выполняется код, когда более детально ознакомитесь с данным руководством. Боковая панель результатов - это основное место, которое вы будете искать, чтобы убедиться в том, что ваш код работает так, как ожидалось.
  
3. `Execution control`: код в playground выполняется автоматически по умолчанию, что означает, что вы можете писать код и сразу видеть результат. В то же время этот элемент управления позволяет выполнять код тогда, когда это нужно. Удерживание кнопки` ▶ ︎ (Execute)` позволяет переключаться между режимами автоматического выполнения и ручным режимом.
  
4. `Activity viewer`: показывает статус playground. На скриншоте выше показано, что playground закончил выполнение  кода. Когда playground находится в процессе исполнения кода  `Activity viewer` демонстрирует крутящийся спинер..
  
5. `Panel controls`: эти переключатели показывают и скрывают три панели, одна из которых отображается слева, одна внизу и одна справа. Каждая из панелей отображает дополнительную информацию, которая вам может потребоваться время от времени. Обычно они скрыты, так как они представлены на скриншоте. Вы узнаете больше о каждой из этих панелей при изучении данного руководства.

Playground  выполняет код в редакторе исходного кода сверху вниз. Каждый раз, когда вы изменяете код, playground будет заново выполнять код. Можно
также запускать повторное выполнение, нажав `Editor ▸ Run Playground` в меню. Кроме того, вы можете использовать элемент управления выполнением.

Вы можете включить номера строк в левой части редактора исходного кода, нажав
`Xcode ▸ Preferences… ▸ Text Editing ▸ Line Numbers` в  меню. Номера строк могут быть очень полезны, когда вы хотите обратиться к фрагментам вашего кода.

Когда playground завершит выполнение кода, Xcode обновит боковую панель результатов чтобы показать результаты соответствующих строк в редакторе исходного кода. 

Комментарии в коде, арифметические операции, константы и переменные являются фундаментом  любого языка, и Swift в этом смысле ничем не отличается.

### Коментарии в коде

Компилятор Swift генерирует исполняемый код из редактора исходного кода. Для выполнения этого, он использует код. Иногда большой объем кода не позволит вам по прошествии определенного времени вспомнить, почему вы написали свой код определенным образом или даже какую проблему вы решаете с помощью того или иного фрагмента кода. Чтобы этого не случилось, целесообразно хорошо документировать свой код, чтобы другой человек, который знакомится с вашим кодом, сможет понять его. 

Swift, как и большинство других языков программирования, позволяет документировать код через использование так называемых комментариев. Они позволяют писать любой текст непосредственно рядом с вашим кодом, который игнорируется компилятором.

Первый способ написать комментарий выглядит так:
    
    
    // Это комментарий. Он не выполняется компилятором.
    

Это однострочный комментарий. Вы можете писать их так, чтобы получались целые
абзацы:

    
    // Это тоже комментарий.
    // Из нескольких строк.
    

Однако есть лучший способ написать комментарии, которые состоят из нескольких строк. Вот так: 
    
    /* Это тоже комментарий.
       Из многих...
       многих...
       многих строк. */
    

Это многострочный комментарий. Начало обозначается символом `/ *`, а конец -
обозначается символом `* /`. Все просто!

Вы должны использовать комментарии в своем коде, где это необходимо, чтобы документировать ваш код, объяснять ваши рассуждения или просто оставить шутки для своих коллег. :]

### Комманда print()

Также полезно увидеть результаты того, что делает ваш код. В Swift вы можете добиться этого с помощью команды `print()`.

`print` выводит все, что вы хотите, в область отладки, которая иногда называемый консолью.

Например, рассмотрим следующий код:

    
    print(&quot;Привет, читатель!&quot;)
    

Эта комманда выведет сообщение в область отладки:

[![Print](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-print-650x442.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-print.png)

Вы можете скрыть или отобразить область отладки, используя кнопку-стрелку в нижнем левом углу окна ;выделено красным цветом на изображении выше). Вы также можете нажать `View ▸ Debug Area ▸ Show Debug Area `в меню, чтобы сделать то же самое.

### Арифметические операции

Когда вы берете одну или несколько частей данных и превращаете их в другие
данные, это называется операцией.

Самый простой способ понять операции - вспомнить об арифметике. Операция сложения принимает два числа и преобразует их в сумму двух этих чисел. Операция вычитания принимает два числа и преобразует их вразницу этих двух чисел.

Вы найдете простую арифметику во всех приложениях: от подсчета количества
лайков, до расчета правильного размера и положения кнопки или окна, цифры действительно присутствуют везде!

В этом разделе вы узнаете о различных арифметических операциях, которые
Свифт может предложить, рассматрите как они применяются к числам. Позже вы увидите операции для типов, отличных от чисел.

#### Простые операции

Все операции в Swift используют символ, известный как оператор, для обозначения типа операции которую они выполняют.

Рассмотрим четыре арифметические операции, которые вы изучили в начальной школе: сложение, вычитание, умножение и деление. Для этих простых операций, Swift использует следующие операторы:

  * Сложение: `+`
  * Вычитание: `-`
  * Умножение: `*`
  * Деление: `/`

Примеры использования операторов:

    2 + 6
    
    10 - 2
    
    2 * 4
    
    24 / 3
    

Каждая из этих строк есть не что иное, как вражение. Выражение имеет значение. В этих случаяхвсе четыре выражения имеют одно и то же значение - 8. Вы пишите код для выполнения указанных арифметических операций точно также, как вы могли бы  написать выражения используя перо и бумагу.

[![Broken paper](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-broken-paper-650x355.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-broken-paper.png)

В вашем playground вы можете видеть значения этих выражений в правой части окна редактора, называемой боковая панель результатов:

[![Expressions](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-expressions-650x254.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-expressions.png)

Если хотите, то можно удалить пробелы между аргументами выражения:

    2+6
    
Удаление пробелов между аргументами выражения должно осуществляться по принципу &quot;все или ничего&quot;. Не получится что-то удалит, а что-то оставить. Пример ниже объясняет такой подход:
    
    2+6   // OK
    2 + 6 // OK
    2 +6  // ERROR
    2+ 6  // ERROR
    

Часто бывает проще читать выражения, если по обе стороны от них есть пробелы.

#### Десятичные числа

Для выполнения операций описанных ранее использовались целые числа, больше известные как `integers`. Однако как вы знаете не каждое число может быть целым.

Как пример рассмотрим
 следующее выражение:
    
    22 / 7
    
Вы можете удивиться, узнав, что результат данногов ыражения будет равен 3. Если вы используете только `integers` (целые числа) в выражении, Swift вычислит результат как `integers`. В этом случае, результат округляется до следующего целого числа.

Можно прямо указать Swift'у что необходимо использовать десятичные числа изменив аргументы выражения:
    
    22.0 / 7.0

В этот раз результат будет равен `3.142857142857143`, как и ожидалось.

####  Оператор остатка от деления

Четыре операции, которые вы видели до сих пор легко понять, потому что вы
делали их большую часть своей жизни. Swift также имеет более сложные операции. Сейчас вы с ними познакомитесь.

Первая из них - операция остатка, также называемая модулем. При делении знаменатель переходит в числитель целым числом, при этом остается остаток. Этот остаток - именно то, что операция остатка от деления возвращает. Например, 10 по модулю 3 равно 1, потому что 3 делит 10 три раза нацело, с остатком 1.

В Swift оператор остатка от деления обозначается символом `%` и используется следующим образом:
    
    28 % 10
    
В этом случае результат операции будет равен `8`, потому, что 10 делит 28 нацело два раза с остатком 8. Если вы захотите получить остаток отделения десятичных чисел, вы можете сделать это следующим образом:    
    
    (28.0).truncatingRemainder(dividingBy: 10.0)
    
Это выражение делит 28 на 10, а затем обрезает результат, отрезая любые
дополнительные десятичные числа, и возвращает оставшуюся часть. Результат идентичен ` %`, когда нет десятичных знаков.

#### Операции сдвига (битовые операции)

Операции сдвиг влево и сдвиг вправо принимают двоичную форму десятичного
числа и сдвигают цифры влево или вправо соответственно. Затем они возвращают
десятичную форму нового двоичного числа.

Например, десятичное число 14 в двоичном формате, представляющее собой 8 цифр, равно `00001110`. Смещение влево на два числа (разряда) приводит к `00111000`, что равно
56 в десятичной системе.

Вот иллюстрация того, что происходит во время этой операции сдвига:

![shift_left](https://koenig-media.raywenderlich.com/uploads/2018/09/shift_left.png)


Цифры, которые входят, чтобы заполнить пустоту справа, становятся 0.
цифры, которые выпадают слева, теряются.

Сдвиг вправо тоже самое, но цифры перемещаются вправо.

Операторы для этих двух операций следующие:

  * Shift left: `&lt;&lt;`
  * Shift right: `&gt;&gt;`

Это первые операторы, из тех, с которыми вы познакомились, которые состоят более чем из одного сомвола. На самом деле операторы могут содержать любое количество символов.

Вот пример, который использует оба этих оператора:
    
    1 &lt;&lt; 3
    
    32 &gt;&gt; 2
    
Оба этих значения эквивалентны 8.

Одной из причин использования операции сдвигов является возведение в степень или извлечение квадратного корня, второй - простота. Обратите внимание, что сдвиг влево на одно число это то же самое, что возведение числа в степень 2 (получение квадрата числа), смещение влево на два - это то же самое, что возведение числа в 4-ую степень. Точно так же, смещение вправо на одно число - это то же самое, что извлечение квадратного корня из числа второй степени, смещение вправо на два числа то же самое как извлечени корня 4 степени из числа и т. д.

В старые времена в коде часто использовали этот трюк, потому что побитовый сдвиг
гораздо менее затратно для процессора, чем комплексное умножение и деление арифметика. Поэтому  код выполнялся быстрее, если он использовал сдвиг. Однако с тех самых дней, процессоры стали намного быстрее и компиляторы могут даже преобразовать умножение и деление  в операции сдвига. Таким образом, вы можете никогда не встретить операции сдвига только если вы не станете настоящим системным программистом!

#### Порядок выполнения операций

Очень часто необходимо использовать несколько операторов для вычисления значения. Вот пример того, как это можно сделать в Swift:

    ((8000 / (5 * 10)) - 32) &gt;&gt; (29 % 5)
    
Обратите внимание на то, что в примере используются скобки, которые в Swift служат двум целям: сделать яснее и понятнее чтение кода, включая того, кто код пишет и для устранения неоднозначности. Например, рассмотрим следующий пример:
    
    350 / 5 + 2
 
Результат будет 72 (350 разделено на 5, плюс 2) или 50 (350 разделено на 7)? Те
из вас, кто хорошо учился в школе, скажет «72!» И это будет правильно!

Свифт использует те же правила и так называемый приоритет оператора. Оператор деления (`/`) имеет более высокий приоритет, чем оператор сложения (`+`), поэтому в этом примере код выполняет сначала деление.

Если вы хотите, чтобы Swift сначала выполнил сложение - то есть, вернуть 50 - тогда вы можете использовать круглые скобки:   
    
    350 / (5 + 2)
    
Правила приоритета сответствуют тем же, что вы учили в школе.
Умножение и деление имеют одинаковый приоритет, выше, чем сложение и вычитание, которые также имеют равный приоритет.

### Матматические функции

В Swift также есть широкий спектр математических функций, которые вы можете использовать, когда это необходимо.
Вы никогда не знаете, когда вам нужно использовать тригонометрию, особенно когда
вы профессионал-swifter и пишете сложные игры!

Примечание. Не все эти функции являются частью Swift. Некоторые из них предоставляются операционной системой (ОС). Не удаляйте оператор `import`, который является частью шаблона playground или Xcode подскажут вам, что они не могут найти эти функции.

Например, рассмотрим следующее:
    
    sin(45 * Double.pi / 180)
    // 0.7071067811865475
    
    cos(135 * Double.pi / 180)
    // -0.7071067811865475
    

В этом примере вычиляются синус и косинус, соответственно. Заметьте, что оба выражения используют `Double.pi` - константу предоставляемую вам Swift, возвращающую значение числа Пи, вычисленное с максимально возможной точностью.

Следующий пример:
    
    (2.0).squareRoot() // Same as sqrt(2)
    // 1.414213562373095
    

В этом примере вычиляется квадратный корень из 2. 

Другая общая операция - найти максимальное из двух переменных. Вы можете использовать ее вот так:

    max(5, 10)
    // 10
    
    min(-5, -10)
    // -10
    
Они вычисляют максимум и минимум двух чисел соответственно.

Если вы особенно предприимчивы, вы можете даже объединить эти функции, например так:
 
    max(sqrt(2), Double.pi / 2)
    // 1.570796326794897
    

### Именование данных

В самом примитивном процессе компьютерного программирования всегда происходит манипуляция данными. Помните, что все, что вы видите на экране, можно свести к номерам, которые вы отправьте в ЦП (центральный процессор). Иногда вы сами создаете и работаете с этими данными как например, с различными типами чисел. В других случаях данные поступают в более сложных формах таких как текст, изображения и коллекции.

Используя язык Swift вы можете назначить каждой части данных имя, котороебудет импользоваться для обращения к нему по мере необходимости. Имя несет в себе ассоциированный тип, который обозначает какие данные относятся к имени, например текст, цифры или дата.

Далее вы узнаете о некоторых основных типах, и познакомитесь с другими типами.


#### Константы

Посмотрите на это:
    
    let number: Int = 10
    
Это объявление константы названой `number`, которая имеет тип `Int`. Затем этой константе задается значение равное 10.

&gt;Заметка: Вспомните об операторах, здесь есть еще один: знак эквивалентности `=`, также известен как оператор присвоения.

Тип `Int` может хранить целые числа. Способ хранения десятичных чисел выглдит также:
    
    let pi: Double = 3.14159
    
Это похоже на `Int` константу, за исключением имени типа. В этот раз константа имет тип `Double`, который может хранить десятичные числа высокой точности.

Есть также тип называемый `Float`, которые хранятдесятичные числа с точностью ниже, чем `Double`. Фактически `Double` это тип, который имеет точность в два раза большуу, чем `Float`, собственно поэтому `Double` так называется. `Float`занимает меньше памяти, чем `Double`, но в основном память используемая для чисел не занимает много места, поэтому чаще в программировании используется тип `Double`.

Однажды объявив константу вы не сможете изменить ее данные. Например, рассмотрим следующий код: 
        
    let number: Int = 10
    number = 0
    
Этот код вызовет ошибку:

	`Cannot assign to value: 'number' is a 'let' constant`

В Xcode вы можете увидеть ошибку 
In Xcode, you would see the error изображенную на следующем скриншоте:

[![Error](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-error-650x52.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-error.png)

Константы полезны для значений, которые не меняют свое значение. Например, вы смоделировалисамолет и нужно отслеживать число доступных мест из общего количества мест в самолете.  Для общего числа мест в самолете можно использовать константу.

Вы также можете использовать константы, для чего-то похожего на день рождения человека. Даже, хотя его возраст будет изменяться со временем, дата рождения изменяться не будет никогда.

#### Переменные

Часто необходимо изменить данные присвоенныекакому-либо имени. Например, если у вас сохраняется баланс вышего банковского счета вы предпочтете использовать переменную чем константу.


Если данные программы не меняются, то это была бы довольно скучная программа! Но, как вы видели, невозможно изменить данные констант.

Когда вы знаете, что вам нужно изменить некоторые данные, вы должны использовать переменную вместо константы. Объявление переменной аналогично объявлению константы:

    var variableNumber: Int = 42
    
Только первая часть выражения отличается: для объявления константы используется `let`, в то время как для объявления переменной используется `var`

Объявленная переменная может быть изменена в любой момент, в течении всего времени ее существования в коде. Например,, для изменения значени япеременной, объявленной ранее вы можете сделать следующее:
    
    variableNumber = 0
    variableNumber = 1_000_000
    
Для изменения переменой вы просто назначаете ей новое значение.

&gt;Заметка: В Swift, вы можете дополнительно использовать знак нижнего дефиса (underscores) чтобы сделать длинные числа более удобными для чтения. Количество и расположение подчеркиваний зависит от вашего желания.

Это хорошее время познакомится поближе с боковой панелью результатов в playground. Когда вы набираете на клавиатуре код в playground, вы увидитечто результат в боковой панеле результатов справа показывает текущее значение `variableNumber` в каждой строке

[![Variables](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-variables-650x43.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-variables.png)

Результат в боковом меню результатов будет показывать относительный результат для каждой строкие сли она существует в коде. В случае константы или переменной результат будет иметь новое значение, объявили ли вы только что константу илиобъявили или переприсвоили значение переменной.

#### Использование толковых имен

Всегда пытайтесь выбирать имена для ваших переменных или констант имеющих хоть какой-то смыл, значение. Хорошее название, как хороший комментарий, может сделать ваш код легким для чтения.

Хорошее имя _точно_ описывает что из себя представляет константа или переменная.
Вот нескольк примеров хороших имен:

  * `personAge`
  * `numberOfPeople`
  * `gradePointAverage`

Часто плохое имя это просто имя недостаточно описательное. Вот несколько примеров плохих имен:

  * `a`
  * `temp`
  * `average`

Имя должно гарантировать, что вы поймете, к чему относятся переменная или константа, когда вы будете обращатся к ним позже. Не делайте ошибку, думая, что вы имеете феноменальную память! В компьютерном программировании принято оглядываться назад и очень часто даже свой код можно забыть уже через день-два и забыть, что он делает. Сделайте проще для себя, присвоив переменным и константам интуитивно понятные точные названия.

Кроме того, обратите внимание, как написаны имена выше. В Swift, принят так называемы кэмел стиль написания имен. Для переменных и констант должны соблюдаться  следующие правила написания имен:

  * начало имени с прописной буквы. 
  * если имя состоит из нескольких слов, соедините х вместе, при этом начало каждого последующего слова, за исключением первого должно начинаться с заглавной буквы.
  * Если одно из этих слов является аббревиатурой, напишите всю аббревиатуру в целиком так, как она пишется(например, `sourceURL` и `urlDescription`). 


В Swift можно использовать полный диапазон символов Юникода. Например, можно объявить переменную следующим образом:

    var 🐶💩: Int = -1
    

Это может показаться прикольным, но будьте осторожны с такими специальными символами. Они относятся к сложному типу и, следовательно, могут в конечном итоге причинить вам больше боли, чем развлечения.

[![Bad choice](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-bad-choice.png)](https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-1-bad-choice.png)

Специальные символы, подобные этим, вероятно, имеют больше смысла в _данных_, которые вы храните, а не в Swift-коде.

### Инкремент и декремент

Обычная операция, которая вам понадобится, чтобы иметь возможность увеличивать или уменьшать переменные. В Swift это достигается следующим образом:
    
    var counter: Int = 0
    
    counter += 1
    // counter = 1
    
    counter -= 1
    // counter = 0
    
Переменная `counter` начинается с `0`. Инкремент устанавливает свое значение в `1`, и затем декремент устанавливает свое значение обратно в `0`.

Эти операторы аналогичны оператору присваивания ( `=` ), за исключением того, что онитакже выполняют сложение или вычитание. Они принимают текущее значение
переменной, добавляют или вычитают данное значение и присваивают результат
перемпенной.

Другими словами, приведенный выше код является сокращением для следующего:
    
    var counter: Int = 0
    
    counter = counter + 1
    // counter = 1
    
    counter = counter - 1
    // counter = 0
    
Похожим образом работают операторы `*=` (умножения) и `/=` (деления), соответственно.    
    
    var counter: Int = 10
    
    counter *= 3 // Same as counter = counter * 3
    // counter = 30
    
    counter /= 2 // Same as counter = counter / 2
    // counter = 15
    

### Что дальше?

Вы можете загрузить [финальный файл](https://koenig-media.raywenderlich.com/uploads/2018/09/Swift-Tutorial-Part-1.zip) playground. Там же  вы найдете мини-упражнения для выполнения. Если вы застряли или вам нужна помощь, не стесняйтесь воспользоваться сопутствующими решениями.

В этом уроке вы имели дело только с числами - целыми числами и
десятичное число. Конечно, dреальном мире есть гораздо больше, чем только числа! В следующем уроке в рамках этой серии вы узнаете о других типах, таких как строки, которые позволяют хранить текст.</content><author><name></name></author><category term="swift" /><category term="programming" /><summary type="html">Добро пожаловать в мини-серию о начале программирования на языке Swift! В в этой серии вы узнаете основы программирования на Swift. Данный материал является переводом tutorial с сайта raywenderlich.com.</summary></entry><entry><title type="html">Как много денег потратил генеральный директор Apple Тим Кук в попытках предотвратить президентство Дональда Трампа</title><link href="https://losthuman.ru/categories/technews/2018/10/06/kak-mnogo-deneg-potratil-generalnyj-direktor.html" rel="alternate" type="text/html" title="Как много денег потратил генеральный директор Apple Тим Кук в попытках предотвратить президентство Дональда Трампа" /><published>2018-10-06T00:00:00+05:00</published><updated>2018-10-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/technews/2018/10/06/Kak-mnogo-deneg-potratil-generalnyj-direktor</id><content type="html" xml:base="https://losthuman.ru/categories/technews/2018/10/06/kak-mnogo-deneg-potratil-generalnyj-direktor.html">По [сообщению]({{page.source_url}}) портала **Businessinsider** cортудники Apple совсем не хотели, чтобы президентом США стал Дональд Трамп, ну, как минимум не хотел Тим Кук.

Подробный [анализ политических пожертвований, сделанных сотрудниками Apple](https://gov predict.com/blog/contributions-by-apple-employees/)
ясно показывает, что Хиллари Клинтон была крупным бенефициаром пожертвований от компании из Купертино.

В общей сложности она получила 1,8 млн. долларов от сотрудников Apple. Главным пожертвователем был Тим Кук, он направил в избирательный фонд Хилари Клинтон самую крупну сумму из всех персональных пожертвований купертиновцев - 236 100 долларов.

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;und&quot; dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://t.co/hrCAaTz96Y&quot;&gt;pic.twitter.com/hrCAaTz96Y&lt;/a&gt;&lt;/p&gt;&amp;mdash; Joshua Cohen (@jcohen570) &lt;a href=&quot;https://twitter.com/jcohen570/status/768609363086815232?ref_src=twsrc%5Etfw&quot;&gt;August 25, 2016&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

В противоположность этому факту персонал Apple внес только 6 786 долларов в фонд избирательной кампании Трампа в 2016 году. Пожертвования Apple Клинтон также затмили 610 805,00 долларов сделанные работниками Amazon.

Пожертвование Тима Кука в избирательный фонд Клинтон контрастирует с его довольно скромными политическими взносами в прошлом, которые были парктически равномерно распределены между демократами и республиканцами.

![Пожертвования генерального директора Applе]({{page.images_url}}1.png)

[По информации CNBC](https://www.cnbc.com/2016/08/24/apples-tim-cook-has-spread-his-political-money-to-both-sides-of-the-aisle.html), Кук лично внес 10 800,00 долларов республиканским кандидатом на их кампании начиная с 2008 года, и и за тот же период он отдал 10 400,00 долларов кандидатам от демокартической партии США.

Кук также рассматривался как потенциальный кандидат на пост вице-президента США, в случае победы Клинтон  на президентских выборах 2016 года. Эта информация просочилась в прессу после утечек конфиденциальной информации, которая была опубликована Wikileaks.

С тех пор как Трамп был избран, Кук занял прагматичный подход к отношениям с
президентом. Они встречались несколько раз, включая проведение
последних переговоров по поводу торговой войны с Китаем.

В целом же персонал Apple пожертвовал более чем 1,3 млн. долларов в избирательные фонды демократов в 2016 году, и всего лишь около 232 тысяч долларов на компании республиканской партии США.</content><author><name></name></author><category term="apple" /><summary type="html">По сообщению портала Businessinsider cортудники Apple совсем не хотели, чтобы президентом США стал Дональд Трамп, ну, как минимум не хотел Тим Кук.</summary></entry><entry><title type="html">Facebook и Apple подтвердили, что они были целью хакерских атак Supermicro</title><link href="https://losthuman.ru/categories/technews/2018/10/06/facebook-apple-podtverdili-chto-oni-byli.html" rel="alternate" type="text/html" title="Facebook и Apple подтвердили, что они были целью хакерских атак Supermicro" /><published>2018-10-06T00:00:00+05:00</published><updated>2018-10-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/technews/2018/10/06/Facebook-Apple-podtverdili-chto-oni-byli</id><content type="html" xml:base="https://losthuman.ru/categories/technews/2018/10/06/facebook-apple-podtverdili-chto-oni-byli.html">Интрига нарастает. В [материале]({{page.source_url}}) **Mashable** сообщается, что после [доклада Bloomberg](https://www.bloomberg.com/news/features/2018-10-04/the-big-hack-how-Китай-используется-в-маленьких-чип-корни-Америка-с-топ-компаний) о китайской атаке через цепочку поставок комплектующих производителя серверов Supermicro в крупные американские компании, включая Apple и Amazon, начала появляться реакция  от некоторых участников этой драмы. Две из этих крупных американских компаний, подтвердили, что пострадали от вредоносной атаки: это Apple и Facebook.

В отличие от Amazon и отрицавшей в первоначальном заявлении Apple, теперь
Facebook и та же Apple подтвердили, что нашли вредоносное ПО всерверах Supermicro.

Facebook сообщил, что компания была осведомлена о серверах со скомпрометированной прошивкой в 2015 году на &quot;ограниченноь количестве оборудования Supermicro&quot;, которое были использованыо только &quot;для
целей тестирования и его (оборудования) импользование было ограничено нашими лабораториями&quot;. Другими словами, Facebook говорит, что атака не затронула пользователей. После такого сообщения невольно в памяти всплывает дело компании
с нарушением персональных данных, которое затронуло [50 миллионов человек](https://mashable.com/article/facebook-50-million-accounts-hacked/).

Apple заявила, что обнаружила вредоносное ПО на одном сервере в 2016 году. Это не противоречит отрицанию аппаратной атаки. На самом деле, это укрепляет его, потому что Apple указывает на вредоносное ПО в качестве причины он отказа сотрудничества с  Supermicro в качестве поставщика в 
[официальном заявлении](https://www.apple.com/newsroom/2018/10/what-businessweek-got-wrong-about-apple/), а не наличие вредоносных микрочипов в
серверах.

Это подтверждение от обоих компаний требует дополнительного анализа и осмысления, однако однозначно то, что китайские хакеры предпринимали попытки незаконного доступа к данным американских компаний и их пользователей. Это то, что китайское правительство отрицало, в ответ на запрос агенства Bloomberg. Что остается неясным, так это размер атаки, а также то по каким причинам Amazon и Apple отрицают наличие аппаратной атаки со стороны китайцев.</content><author><name></name></author><category term="security" /><category term="apple" /><category term="google" /><category term="amazon" /><summary type="html">Интрига нарастает. В материале Mashable сообщается, что после доклада Bloomberg о китайской атаке через цепочку поставок комплектующих производителя серверов Supermicro в крупные американские компании, включая Apple и Amazon, начала появляться реакция от некоторых участников этой драмы. Две из этих крупных американских компаний, подтвердили, что пострадали от вредоносной атаки: это Apple и Facebook.</summary></entry><entry><title type="html">Видео курс для начинающих по IOS разработке (Objective-C)</title><link href="https://losthuman.ru/categories/code/2018/10/06/video-kurs-dlja-nachinajuschih-po-ios.html" rel="alternate" type="text/html" title="Видео курс для начинающих по IOS разработке (Objective-C)" /><published>2018-10-06T00:00:00+05:00</published><updated>2018-10-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2018/10/06/Video-kurs-dlja-nachinajuschih-po-IOS</id><content type="html" xml:base="https://losthuman.ru/categories/code/2018/10/06/video-kurs-dlja-nachinajuschih-po-ios.html">Среди всех свободно распространяемых в сети курсов по разработке для IOS на русском языке стоит отдельно выделить канал [Алексея Скутаренко](https://vk.com/iOSDevCourse). Очень подробный курс для начинающих разраблтчиков, состоящий из 51 видео, а также домашних заданий после каждого урока. Посмотреть правильно ли решено задание можно в группе Вконтакте [iOS Development Course](https://vk.com/iosdevcourse). Там же можно задать накопившиеся вопросы, касающиеся разработки для IOS.

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/NOcflN85_vg&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;&lt;/iframe&gt;

Несмотря на то, что данный курс создан 4 года назад и на Objective-C, основы программирования изложенные в нем для IOS по прежнему актуальны.</content><author><name></name></author><category term="IOS" /><category term="programming" /><summary type="html">Среди всех свободно распространяемых в сети курсов по разработке для IOS на русском языке стоит отдельно выделить канал Алексея Скутаренко. Очень подробный курс для начинающих разраблтчиков, состоящий из 51 видео, а также домашних заданий после каждого урока. Посмотреть правильно ли решено задание можно в группе Вконтакте iOS Development Course. Там же можно задать накопившиеся вопросы, касающиеся разработки для IOS.</summary></entry></feed>