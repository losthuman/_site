<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru_RU"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://losthuman.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="https://losthuman.ru/" rel="alternate" type="text/html" hreflang="ru_RU" /><updated>2019-06-02T21:38:32+05:00</updated><id>https://losthuman.ru/feed.xml</id><title type="html">Losthuman</title><subtitle>Ничего особо ценного</subtitle><entry><title type="html">Jekyll’s tricks минификация HTML и CSS</title><link href="https://losthuman.ru/categories/code/2019/06/02/jekyll-s-tricks-minifikatsija-html-i-css.html" rel="alternate" type="text/html" title="Jekyll's tricks минификация HTML и CSS" /><published>2019-06-02T00:00:00+05:00</published><updated>2019-06-02T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/06/02/Jekyll's-tricks-minifikatsija-HTML-i-CSS</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/06/02/jekyll-s-tricks-minifikatsija-html-i-css.html">&lt;p&gt;Если вас тоже раздражает беспорядочная верстка, которую производит движок Jekyll, предлагаю воспользоваться простыми и эффективными способами минифицировать css и html. Без использования плыгинов Jekyll, без Gulp’а, Grunt’а, Rake и прочих приспособ.&lt;/p&gt;

&lt;h3 id=&quot;минификация-css&quot;&gt;Минификация CSS&lt;/h3&gt;

&lt;p&gt;Jekyll и GitHub Pages уже поддерживают &lt;a href=&quot;http://sass-lang.com&quot;&gt;Sass&lt;/a&gt; и
&lt;a href=&quot;http://coffeescript.com&quot;&gt;CoffeeScript&lt;/a&gt; по умолчанию, поэтому можно воспользоваться возможностями оптимизации доступными с Sass.&lt;/p&gt;

&lt;p&gt;Для этого в конфигурационном файле &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; надо помимо всего прочего указать:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sass:
    style: compressed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В результате получим файл стилей содержащий одну сжатую и непрерывную строку кода.&lt;/p&gt;

&lt;h3 id=&quot;минификация-html&quot;&gt;Минификация HTML&lt;/h3&gt;

&lt;p&gt;В отличии от Sass, Jekyll не поддерживает возможность для минификации сгенерированного HTML кода. Однако, есть простое решение, не сязанное с конфигурационными настройками Jekyll. Это решение предложенное &lt;a href=&quot;http://penibelst.de/&quot;&gt;Anatol Broder&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Anatol создал &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;, который удаляет лишние пробелы из контента сгенерировааной HTML страницы. Чтобы применить это решение надо скачать файл &lt;a href=&quot;https://github.com/penibelst/jekyll-compress-
html/releases/tag/v1.1.1&quot;&gt;compress.html&lt;/a&gt; и добавить его в папку &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;. Этот файл содержит код, написанный преимущественно на &lt;code class=&quot;highlighter-rouge&quot;&gt;liquid&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-06-02-Jekyll's-tricks-minifikatsija-HTML-i-CSS//1.jpg&quot; alt=&quot;compress.html&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Затем надо настроить корневой &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;. Например, если в качестве корневого &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt; используется &lt;code class=&quot;highlighter-rouge&quot;&gt;default.html&lt;/code&gt;, то в этом файле надо прописать соответствующий &lt;code class=&quot;highlighter-rouge&quot;&gt;front matter&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: compress
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В результате получим оптимизированный HTML код.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://vk.com/losthuman_ru&quot;&gt;Все новости в группе Вконтакте&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><summary type="html">Если вас тоже раздражает беспорядочная верстка, которую производит движок Jekyll, предлагаю воспользоваться простыми и эффективными способами минифицировать css и html. Без использования плыгинов Jekyll, без Gulp’а, Grunt’а, Rake и прочих приспособ.</summary></entry><entry><title type="html">Статический сайт на Jekyll и GitHub Pages</title><link href="https://losthuman.ru/categories/code/2019/05/25/statichesky-sait-na-jekyll-i-github-pages.html" rel="alternate" type="text/html" title="Статический сайт на Jekyll и GitHub Pages" /><published>2019-05-25T00:00:00+05:00</published><updated>2019-05-25T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/05/25/Statichesky-sait-na-jekyll-i-GitHub-Pages</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/05/25/statichesky-sait-na-jekyll-i-github-pages.html">&lt;p&gt;Хотя большинство блогеров, начиная свою карьеру на отдельном ресурсе  выбирают  для своего творчества либо Wordpress, либо похожую платформу, самые продвинутые  и самые экономные предпочитают со временем перебраться на статику. И, одним из самых популярных движков для генерации статических сайтов по праву считается &lt;a href=&quot;https://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;. Не последнюю роль в этой популярностия играет то, что jekyll поддерживается создателями и командой GitHub, а также имеющейся возможностью бесплатно хостить сайты на Gihub Pages. Собственно, об этом и речь.&lt;/p&gt;

&lt;p&gt;Установка и настройка проекта на Jekyll довольно просты и весьма подробно описаны в &lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;официальном руководстве&lt;/a&gt;. Просто и быстро.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/1.jpg&quot; alt=&quot;Установка Jekyll&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Допустим, что все минимальные требования мы выполнили и получили работающий проект jekyll с самым простым статическим сайтом. Допустим, что это будет сайт с дефолтной темой  minima (аналог underscores для wordpress). И, посты написаны, ну один-то уж точно написан. Пора разместить сайт на хосте и сделать его доступным для мира.&lt;/p&gt;

&lt;p&gt;Самы простой способ - это использовать встроенную в GitHub Pages интеграцию с jekyll. Для начала надо создать новый репозиторий на GitHub.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/2.jpg&quot; alt=&quot;Создание нового репозитория&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Далее надо последовательно заполнить поля, необходимые для начальной конфигурации.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/3.jpg&quot; alt=&quot;Поля для начальной конфигурации&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Указываем имя нового репозитория (обязательное поле);&lt;/li&gt;
  &lt;li&gt;Указываем описание содержания нового репозитория (опциональное поле);&lt;/li&gt;
  &lt;li&gt;Указываем статус нового репозитория как публичный, доступный всем пользователям (обязательное поле). В случае создания приватного репозитория его невозможно будет использвать как хостинг для нашего сайта;&lt;/li&gt;
  &lt;li&gt;Добавляем файл .gitignor для jekyll (опциональное поле). В любом случае для создания нового репозитория необходимо создать какй-нибудь файл. Выбор на данном этапе невелик. Либо это .gitignor, либо README.md. По крайней мере .gitignor нам пригодится в будущем;&lt;/li&gt;
  &lt;li&gt;Нажимаем кнопку &lt;code class=&quot;highlighter-rouge&quot;&gt;Create repository&lt;/code&gt;. Дело сделано.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/4.jpg&quot; alt=&quot;Созданный репозиторий&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Далее нажимаем кнопку &lt;code class=&quot;highlighter-rouge&quot;&gt;Settings&lt;/code&gt; на панели управления репозиторием.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/5.jpg&quot; alt=&quot;Настройки репозитория&quot; /&gt;&lt;/p&gt;

&lt;p&gt;На странице настройки надо найти раздел &lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub Pages&lt;/code&gt; и в разделе нажать на выпадающий список в категории &lt;code class=&quot;highlighter-rouge&quot;&gt;Source&lt;/code&gt;. В выпавшем списке надо нажать на пункт &lt;code class=&quot;highlighter-rouge&quot;&gt;master branch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/6.jpg&quot; alt=&quot;Выбор источника&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Выбранный источник будет содержать наш проект, который мы сделали на jekyll. После нажатия на пункт &lt;code class=&quot;highlighter-rouge&quot;&gt;master branch&lt;/code&gt; страница настроек перегрузится и в разделе &lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub Pages&lt;/code&gt; мы получим ссылку на наш сайт.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/7.jpg&quot; alt=&quot;Настройки GitHub Pages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Однако, после перехода по этой ссылке, все, что можно увидеть - это страница с ошибкой 404.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/8.jpg&quot; alt=&quot;Ошибка 404&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Все сделано правильно, но в репозитории ничего кроме файла &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignor&lt;/code&gt; нет. Пришло время переместить проект jekyll в новый, только что созданный репозиторий.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/9.jpg&quot; alt=&quot;Копируем адрес репозитория&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Копируем адрес нового репозитория и с помощью терминала слонируем этот репозиторий на локалном диске компьютера с помошью команды &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone &amp;lt;name repository&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/10.jpg&quot; alt=&quot;Клонируем репозиторий&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/11.jpg&quot; alt=&quot;Клонируем репозиторий&quot; /&gt;&lt;/p&gt;

&lt;p&gt;После создания директории с именем &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; надо перейти в нее с помощью команды  &lt;code class=&quot;highlighter-rouge&quot;&gt;cd test/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/12.jpg&quot; alt=&quot;Новая директория&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Далее от по обстоятельствам. Если у вас уже есть  готовый и рабочий проект Jekyll, то можно просто скопировать его в эту директорию. Или, инициализировать новый, опять таки в этой самой директории. Сделать это можно командой &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new .&lt;/code&gt;. Я для данного примера создам заново проект jekyll.&lt;/p&gt;

&lt;p&gt;После создания проекта jekyll надо запушить этот проект прямо в репозиторий на GitHub. Делаем это последовательно выполняя следующие команды (но, если вы спеу по git, то сможете сделать это меньшим количеством строк кода):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git add .
 git commit -m &quot;initial commit&quot;
 git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После, заглянем в репозиторий на Github.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/13.jpg&quot; alt=&quot;Репозиторий после загрузки&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Если, сразу после этого перейти по ссылке &lt;code class=&quot;highlighter-rouge&quot;&gt;https://losthuman.github.io/test/&lt;/code&gt;, то результат однозначно вас разочарует.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/14.jpg&quot; alt=&quot;сайт&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Надо подправить ссылки на таблицы стилей в проекте. Для чего прямо в репозитории надо открыть файл &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/15.jpg&quot; alt=&quot;Редактируем config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В файле &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; надо изменить переменные &lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;baseurl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/16.jpg&quot; alt=&quot;Редактируем config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Для редактирования надо нажать на иконку редактирования файла. После чего откроется страница редактирования. В переменную &lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt; передадим &lt;code class=&quot;highlighter-rouge&quot;&gt;https://losthuman.github.io&lt;/code&gt;, а в &lt;code class=&quot;highlighter-rouge&quot;&gt;baseurl&lt;/code&gt; передадим директорию с именем репозитория &lt;code class=&quot;highlighter-rouge&quot;&gt;/test&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/17.jpg&quot; alt=&quot;редактируем переменные&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Чтобы изменения вступили в силу надо их закоммитить. Надо указать описание коммита и нажат на кнопку &lt;code class=&quot;highlighter-rouge&quot;&gt;Commit Changes&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/18.jpg&quot; alt=&quot;Коммит&quot; /&gt;&lt;/p&gt;

&lt;p&gt;После этого вновь проверим ссылку &lt;code class=&quot;highlighter-rouge&quot;&gt;https://losthuman.github.io/test/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-05-25-Statichesky-sait-na-jekyll-i-GitHub-Pages/19.jpg&quot; alt=&quot;сайт&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Все получилось. Сайт опубликован и для этого мы не заплатили ни копейки. Круто!&lt;/p&gt;

&lt;p&gt;После, не забудьте перенести изменения, сделанные в репозитории GutHUb в локальную директорию. Сделать это можно в терминале с помощью команды &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="GitHub" /><category term="GitHub Pages" /><summary type="html">Хотя большинство блогеров, начиная свою карьеру на отдельном ресурсе выбирают для своего творчества либо Wordpress, либо похожую платформу, самые продвинутые и самые экономные предпочитают со временем перебраться на статику. И, одним из самых популярных движков для генерации статических сайтов по праву считается Jekyll. Не последнюю роль в этой популярностия играет то, что jekyll поддерживается создателями и командой GitHub, а также имеющейся возможностью бесплатно хостить сайты на Gihub Pages. Собственно, об этом и речь.</summary></entry><entry><title type="html">Основы программирования и Playground. Часть 2</title><link href="https://losthuman.ru/categories/code/2019/01/30/osnovy-programmirovaniya-playground-chast-2.html" rel="alternate" type="text/html" title="Основы программирования и Playground. Часть 2" /><published>2019-01-30T00:00:00+05:00</published><updated>2019-01-30T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/30/Osnovy-programmirovaniya-Playground-chast-2</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/30/osnovy-programmirovaniya-playground-chast-2.html">&lt;p&gt;Инструменты, которые мы будем использовать в  ходе написание кода, относятся к программным средствам. Одним из таких инструментов является Интегрированная среда разработки или IDE. Наиболее распространенная среда для Swift – это Xcode, которым вы будете пользоваться.&lt;/p&gt;

&lt;h3 id=&quot;набор-инструментов-для-написания&quot;&gt;Набор инструментов для написания&lt;/h3&gt;

&lt;p&gt;Xcode обладает очень полезной опцией, которая носит название Playground (“песочница”, игровая площадка). Это опция позволяет быстро разрабатывать и тестировать код без необходимости построения финального варианта программы. Playground будет неоднократно вами использоваться для написания вашего кода, поэтому важно понять, как она работает. Это, собственно, то, чему вы научитесь в остальной части этой главы.&lt;/p&gt;

&lt;h3 id=&quot;создание--playground&quot;&gt;Создание  Playground&lt;/h3&gt;

&lt;p&gt;При открытии Xcode, среда разработки будет приветствовать вас:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-30-Osnovy-programmirovaniya-Playground-chast-2/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Если же вы не видите этого на экране своего монитора, то вероятнее всего опция, отвечающая за отображение окна приветствия, была отключена. Вы также можете открыть это окно, зажав комбинацию клавиш &lt;code class=&quot;highlighter-rouge&quot;&gt;Command-Shift-1&lt;/code&gt; или нажав на &lt;code class=&quot;highlighter-rouge&quot;&gt;Window\Welcome&lt;/code&gt; to Xcode в строке меню.&lt;/p&gt;

&lt;p&gt;Вы можете незамедлительно переместиться из окна приветствия в Playground, нажав на Get started with a playground. Нажав на данную команду, Xcode перенесёт вас в следующее окно:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-30-Osnovy-programmirovaniya-Playground-chast-2/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Здесь вы можете выбрать платформу. На данный момент ей могут быть iOS, macOS или tvOS. Выбранная вами платформа попросту определяет шаблон Playground. Каждая из них обладает своей средой и средствами к работе с вашим кодом. Основываясь на целях нашей программы, выбирайте то, что вам ближе: наше обучение основано на языке Swift, но не на конкретной платформе.&lt;/p&gt;

&lt;p&gt;Как только вы определитесь с платформой, вы можете дать название своему Playground. Название является лишь формальностью и не играет роли, поэтому после создания Playground, вы можете абсолютно спокойно давать любое название вашему творению с учётом личного удобства. Например, вы можете дать ей название &lt;code class=&quot;highlighter-rouge&quot;&gt;MyPlayground.playground&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-30-Osnovy-programmirovaniya-Playground-chast-2/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Нажмите на &lt;code class=&quot;highlighter-rouge&quot;&gt;Create&lt;/code&gt; и затем сохраните Playground. Xcode в последствие отобразит выбранный вами Playground:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-30-Osnovy-programmirovaniya-Playground-chast-2/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Работа с новым Playground начинается не с абсолютно чистого листа: некоторые базисы кодировки для начинающих уже имеются. Однако не волнуйтесь – в скором времени вы поймёте, как работать с кодом.&lt;/p&gt;

&lt;h3 id=&quot;обзор--playground&quot;&gt;Обзор  Playground&lt;/h3&gt;

&lt;p&gt;На первый взгляд может показаться, что Playground является причудливым текстовым редактором. В сущности говоря, так и есть!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-30-Osnovy-programmirovaniya-Playground-chast-2/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Верхние скриншоты отображают первостепенную информацию:
1.&lt;code class=&quot;highlighter-rouge&quot;&gt;Source editor&lt;/code&gt;: это пространство для написания вашего кода похожее на Notepad или TextEdit. Вы можете заметить наличие так называемого моноширинного шрифта, при котором ширина всех символов одинакова. За счёт данного типа шрифта форматирование и чтение кода становятся довольно простыми.&lt;/p&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;Results side bar&lt;/code&gt;: это пространство отображает результат вашей работы. Вы узнаете больше о том, как реализуется сам код по мере прочтения книги. Results side bar ваш главный инструмент для проверки корректности написания кода и его работы.&lt;/p&gt;

&lt;p&gt;3.&lt;code class=&quot;highlighter-rouge&quot;&gt;Execution control&lt;/code&gt;: код написанный в Playground исполняется автоматически, т.е., написав его, вы можете незамедлительно увидеть отдачу. Эта опция позволяет вам реализовывать ваш код в Playground сколько угодно. Зажимая клавишу, вы можете переключаться между автоматическим и ручным режимами исполнения.&lt;/p&gt;

&lt;p&gt;4.&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity viewer&lt;/code&gt;: эта опция отображает статус Playground. Другими словами – завершил ли Playground исполнение написанного и готов ли  работать дальше с исходным кодом. При процессе исполнения пользователь будет оповещён символом в виде вертящегося спинера.&lt;/p&gt;

&lt;p&gt;5.&lt;code class=&quot;highlighter-rouge&quot;&gt;Panel controls&lt;/code&gt;: данная опция позволяет скрывать и отображать три панели. Одну слева, одну снизу и одну справа. Панели содержат дополнительную информацию, которая может вам пригодиться для дальнейшей работы. Однако обычно они скрыты как на скриншоте.  Вы узнаете больше о каждой из панелей в дальнейшем.&lt;/p&gt;

&lt;p&gt;Playground реализует исполняемый код, начиная с самого начала, стремясь вниз. Каждый раз, когда вы будете изменять код, Playground будет совершать переисполнение, заменяя компоненты. Вы также можете сами запустить функцию переисполнения, нажав Editor\Execute Playground. Вы также можете изменять параметры исполнения кода.&lt;/p&gt;

&lt;p&gt;Мы можете включить нумеровку, которая находится слева от исходного кода, нажав &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode \Preferences...\Text Editing\Line Numbers&lt;/code&gt;. Она может быть полезной в случаях, когда нужно сослаться на конкретные части кода. 
Как только исполнение кода будет завершено, Xcode обновит результат на боковой панели и покажет соответствующие строки рядом с исходным кодом. Вы узнаете как использовать результат вашего творения в дальнейшем.&lt;/p&gt;

&lt;p&gt;Ключевые моменты
    • Самые фундаментальные процессы, исполняемые компьютером, базируются на элементарной арифметике. 
    • Язык программирования позволяет вам писать код, который компилятор, в свою очередь, конвертирует в операции, исполняемые ЦП. 
    • Работа компьютера построена на двоичной (бинарной) системе счисления.
    • Интегрированная среда разработки, используемая нами для реализации Swift – это Xcode.
    • Получая моментальный отчёт о том, как код исполнен, Playground предоставляет возможность писать на языке Swift и тестировать его с крайне большой скоростью и эффективностью.&lt;/p&gt;

&lt;h3 id=&quot;что-дальше&quot;&gt;Что дальше?&lt;/h3&gt;

&lt;p&gt;Если вам ещё не предоставлялось возможности, советуем открыть Xcode и создать свой первый Playground. Назовите её Глава 1 и выберите платформу iOS. Сохраните её где-нибудь у себя на жестком диске и вернитесь к вашему “холсту”. Теперь лишь остаётся следовать уготованным в следующей главе инструкциям!&lt;/p&gt;

&lt;p&gt;Данный текст является неавторизированным переводом книги &lt;a href=&quot;https://store.raywenderlich.com/products/ios-apprentice&quot;&gt;iOS Apprentice&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="code swift" /><summary type="html">Инструменты, которые мы будем использовать в ходе написание кода, относятся к программным средствам. Одним из таких инструментов является Интегрированная среда разработки или IDE. Наиболее распространенная среда для Swift – это Xcode, которым вы будете пользоваться.</summary></entry><entry><title type="html">Основы программирования и Playground. Часть 1</title><link href="https://losthuman.ru/categories/code/2019/01/28/osnovy-programmirovaniya-playground-chast-1.html" rel="alternate" type="text/html" title="Основы программирования и Playground. Часть 1" /><published>2019-01-28T00:00:00+05:00</published><updated>2019-01-28T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/28/Osnovy-programmirovaniya-Playground-chast-1</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/28/osnovy-programmirovaniya-playground-chast-1.html">&lt;p&gt;В первой главе мы разберем основы. В начале вы узнаете о том, как работает код, а затем – об инструментах для написания это кода на базе языка программирования Swift.&lt;/p&gt;

&lt;h2 id=&quot;как-работает-компьютер&quot;&gt;Как работает компьютер&lt;/h2&gt;

&lt;p&gt;Можете не верить, но в действительности компьютер сам по себе не является таким уж невероятным вычислительным прибором. Его мощность целиком и полностью зависит от программной архитектуры, написанной людьми, такими же как вы или я. Учитывая тот факт, что вы сейчас читаете эту книгу, можно наверняка сказать, что вы желаете раскрыть потенциал своего компьютера и преуспеть в написании кода. В свою очередь для того, чтобы стать таковым, необходимо понимать, как работает компьютер.&lt;/p&gt;

&lt;p&gt;Вы вновь можете посчитать, что это невероятно, но на самом деле в строении компьютера нет ничего сложного. Его центр или “сердце” – это &lt;strong&gt;Central Processing Unit (CPU)&lt;/strong&gt; или Центральный процессор (ЦП), являющийся по сути вычислительным устройством. Он совершает сложение, вычитание и другие арифметические операции с числами. То есть весь базис функционала компьютера, который вы видите и которым пользуетесь, построен на обработке ЦП многомиллионными числами каждую секунду. Удивительно, как из всего лишь чисел строится целая система.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Процессор помещает числа , с которыми работает, в маленькие устройства памяти, называющиеся регистрами. ЦП вносит числа в регистры, перенося их из главной памяти всего компьютера - &lt;strong&gt;Random Access Memory (RAM)&lt;/strong&gt;. Кроме того, процессор способен вносить числа обратно, из RAM в регистры. Конкретно эта функция позволяет вычислительному устройству работать с большим количеством данных, которое не всегда может полностью поместиться в регистрах. 
Для более наглядного объяснения имеется последовательный план работы этой вычислительной системы.&lt;/p&gt;

&lt;p&gt;Как только ЦП перемещает цифровые величины из RAM в свои регистры, вычислительной устройство производит обработку и помещает числа уже в другой регистр. Каждый последующий раз ЦП совершает вычитание, сложение, заимствует данные из RAM или, наоборот, вносит их. Иными словами, процессор совершает единичную операцию. Обычно всякая компьютерная программа состоит из тысяч или даже миллионов операций. Сложные программы вроде вашей операционной системы macOS (а это тоже программа) могут насчитывать миллионы операций всего.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Не исключена и возможность написания собственной программы, которой будет следовать компьютер, но написание таких программ, не считая более простых, занимает невероятно много времени и довольно сильно утомляет. Всё потому, что большинство программ нацелены на нечто большее, чем просто на простые вычисления. Эти программы предоставляют нам возможности интернет-сёрфинга, работы с фотографиями и общения с друзьями.&lt;/p&gt;

&lt;p&gt;Таким образом, вместо написания собственной уникальной программы, вам следует реализовывать их на уже готовых основах, т.е. в виде специальных  языков программирования (в ваше случае это Swift). Этот язык реализуется через программу, называемую компилятором, которая переводит написанный вами код в операцию, которую ЦП знает, как совершить. Каждая строка написанного вами кода будет переведена во множество операций, некоторые из них могут обратиться даже в целые алгоритмы!&lt;/p&gt;

&lt;h2 id=&quot;системы-счисления&quot;&gt;Системы счисления&lt;/h2&gt;

&lt;p&gt;Как вы уже могли понять, числа являются своего рода “топливом” любого компьютера, его незаменимой основой. Какая бы информация не обрабатывалась, в конечном итоге она предстаёт в виде чисел. К примеру, каждый символ в конкретно взятом отрывке кода представлен в виде цифры. Мы разберём этот момент подробнее в 3 главе, которая будет посвящена строковому типу данных.&lt;/p&gt;

&lt;p&gt;Кстати говоря, с изображениями та же история: в компьютере они так же представлены в виде чисел. Изображение разбито на множество тысяч или даже миллионов частей, называемых пикселями. Каждый пиксель обладает своим ярко-выраженным единым цветом. Если вы хорошенько всмотритесь в свой компьютер, то сможете, скажем, различить их цветовые границы, при учете, что у вас будет монитор с высоким разрешением, где пиксели, как правило,  крайне малы. Каждый из этих элементов цветовой системы обычно состоит из 3 трех чисел: одно прикреплено к некоторому количеству красного цвета, второе - к зелёному и, наконец, третье - к синему. Как пример: пиксель абсолютно красного цвета имел бы параметры в виде 100% красного и, соответственно, 0% зелёного и синего.&lt;/p&gt;

&lt;p&gt;Стоит отметить, что сам процессор работает не совсем с обычным типом чисел, которые мы привыкли видеть и привыкли использовать каждый день. На этот раз нам придётся работать с так называемой “десятичной системой счисления”. На самом деле даже на интуитивном уровне можно понять то, как она работает. Однако, для наглядного примера рассмотрим работу процессора с десятичной системой счисления. Например, число 423 имеет 3 единицы, 2 десятка и 4 сотни:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В рассматриваемой нами системе каждая отдельно взятая цифра целого числа может иметь величину от 0 до 9, т.е. всего 10 возможных величин для каждой цифры. Именно по этому эта система имеет название десятичной!&lt;/p&gt;

&lt;p&gt;На самом деле величины цифры полностью зависит от положения самой цифры в числе. Двигаясь справа налево, можно увидеть, как каждая цифра умножается на несколько десятков.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(0 * 1000) + (4 * 100) + (2 * 10) + (3 * 1) = 423
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;То есть самая крайняя правая позиция это десяток с величиной нуля, а следующий, соответственно, уже десяток с величиной единицы. Третья цифра имеет десяток с величиной двойки и так далее по нарастающей. Таким образом, получается, что каждая цифра имеет такую величину десятка, которая соответствует её последовательном номеру в числе, учитывая, что мы начинаем счёт с самой крайней правой позиции.&lt;/p&gt;

&lt;h3 id=&quot;двоичная-система-счисления&quot;&gt;Двоичная система счисления&lt;/h3&gt;

&lt;p&gt;По причине того, что вы уже частично разбираетесь в десятичной системе, вы тратите не так много времени на анализ её чисел. Однако для компьютера эта система покажется довольно таки запутанной, ведь он, как мы уже выяснили до этого, на самом деле простак. Поэтому ему больше подойдет так называемая двоичная система счисления.&lt;/p&gt;

&lt;p&gt;Как не трудно догадаться из названия, в сравнении с предыдущей системой счисления, каждая цифра имеет лишь две величины – 0 и 1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Примечание:&lt;/strong&gt; Как в теории, так и на практике существовали компьютеры, которые были построены на троичной системе счисления. Т.е. величин для цифр было 3 вместо 2. Некоторые программисты, информатики и отчаянные хакеры и по сей день продолжают исследовать возможности данной системы.&lt;/p&gt;

&lt;p&gt;Практически все современные компьютеры на сегодняшний день настроены на данную систему в виду того, что с точки зрения работоспособности гораздо проще манипулировать лишь двумя вариантами величин для цифр. Работа цифровых схем, которыми в оснащён компьютер, построена на наличии электрического напряжения, что обозначается величиной 1, или на его отсутствии, что, как нетрудно догадаться, обозначается величиной 0.&lt;/p&gt;

&lt;p&gt;Для лучше понимания рассмотрим двоичную систему счисления на примере числа 1101:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В десятичной системе мы измеряли величину цифр десятками, умножая сами цифры на них, в данном же случае нам придётся прибегнуть к помощи двоек, т.е. 1, 2, 4, 8, 16 и так далее. Общий принцип работы весьма прост: каждая цифра множится на величину, зависящую от всё того же положения цифры в числе. Умножение начинается справа налево.&lt;/p&gt;

&lt;p&gt;Поэтому в числе 1101 самая правая цифра 1 имеет величину в виде арифметического действия (1 * 2^0), что равняется, соответственно, 1. Величина следующей цифры 0 соответствует действию (0 * 2^1), которое равно 0. В общем-то, как уже было показано на примере принципа работы цифровых схем, величина цифр числа двоичной системы счисления либо выражает цифру (1), как часть целого числа, либо нет (0). 
Приведённое нами в пример число 1101 можно с лёгкостью из двоичной системы перевести в десятичную по аналогии работы десятичной системы, но заменив десятки двойками:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1 * 8) + (1 * 4) + (0 * 2) + (1 * 1) = 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В свою очередь, если вы хотите конвертировать число десятичной системы 423 в двоичную систему, необходимо разбить само число так на двойки:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1 * 256) + (1 * 128) + (0 * 64) + (1 * 32) + (0 * 16) + (0 * 8) + (1 * 4) 	+ (1 * 2) + (1 * 1) = 423
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как вы можете видеть, собрав двоичные цифры в необходимом порядке воедино, мы получим число 110100111. Совершив обратное действие перевода из одной системы в другую, можно легко проверить правильность расчётов.&lt;/p&gt;

&lt;p&gt;Каждая цифра двоичного числа имеет размер в бит, который в свою очередь является единицей измерения информации в двоичной системе. Восемь таких битов составляют один байт, а четыре – один ниббл или полубайт. Такого рода игра с языком в виде придумывания названий показывает, что даже у программистов прошлого с фантазией всё было в порядке.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Тот факт, что компьютер обладает ограниченной памятью, говорит также об ограниченности длины чисел. Каждый регистр, как правило, обладает пределом в 32-бита или в 64-бита. По этой же причине про ЦП говорят как о 32-битном или 64-битном. Таким образом, пределом 32-битного процессора будет число 4,294,967,295 или, переводя в двоичную систему, 11111111111111111111111111111111. Такова его работа.&lt;/p&gt;

&lt;p&gt;Тем не менее процессор способен работать с числами, которые превосходят его вычислительные объёмы. В данном случае вычислительные операции будут разбиты на несколько этапов и займут больше времени аналогично тому, как мы поступали со сложными примерами в школе.&lt;/p&gt;

&lt;h3 id=&quot;шестнадцатеричная-система-счисления&quot;&gt;Шестнадцатеричная система счисления&lt;/h3&gt;

&lt;p&gt;Как вы уже могли догадаться из предыдущего параграфа, работа с двоичной системой может быть скучной и занимающей много времени. По причине этого в программирование существует ещё одна базовая система счисления, называемая шестнадцатеричной. К слову, отдельных символов для всех 16 цифр не нашлось: всего их 10. Поэтому для их обозначения с 10-15 мы используем 6 первых букв английского алфавита:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;• a = 10
• b = 11
• c = 12
• d = 13
• e = 14
• f = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Не стоит удивляться, если первое, что у вас получиться написать из шестнадцатеричного кода, будет похоже на слово.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Это самая забавная часть. 
Величина каждой цифры определяется при помощи шестнадцати, поэтому формула приведения в десятичную систему будет такой:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(12 * 4096) + (0 * 256) + (13 * 16) + (14 * 1) = 49374
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вы можете также переводить буквы в десятичную систему и производить все необходимые вычисления.&lt;/p&gt;

&lt;p&gt;Но зачем же в таком случае увеличивать количество систем счисления?
Всё дело в том, что одна цифра шестнадцатеричной системы может в точности доносить величину четырех цифр двоичной системы. Двоичное число 1111 эквивалентно шестнадцатеричному f. Учитывая это, можно с лёгкостью укорачивать двоичные числа, используя шестнадцатеричную систему.&lt;/p&gt;

&lt;p&gt;Для примера рассмотрим число c0de:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c = 1100
0 = 0000
d = 1101
e = 1110
c0de = 1100 0000 1101 1110
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта опция оказывается весьма полезной, учитывая насколько длинными могут быть двоичные числа на 32-битных и 64-битных процессорах. То есть длиннейшее число для 32-битов 4,294,967,295 двоичной системы может быть записано как ffffffff в шестнадцатеричной.&lt;/p&gt;

&lt;h3 id=&quot;как-работает-код&quot;&gt;Как работает код&lt;/h3&gt;

&lt;p&gt;У компьютера есть много ограничений, и сам по себе он не обладает большим функционалом. Процесс программирования – это процесс расширения функций компьютера путём кодирования, где малые элементы сложены воедино в правильном порядке. 
Кодирование крайне схоже с написанием рецепта: вы собираете все ингредиенты (данные) и даёте компьютеру инструкцию касательного того, как эти самые ингредиенты использовать.
Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Шаг 1. Загрузить фото, находящееся на жестком диске
Шаг 2. Изменить размер фото по параметрам 400 пикселей в ширину и 300 пикселей в высоту
Шаг 3. Применить светло-коричневый фильтр к фото
Шаг 4. Напечатать фото
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Приведённый выше пример является так называемым псевдокодом, т.е. сам по себе код не представляет собой реальный язык программирования, однако он отображает алгоритм, который вы хотите осуществить. В нашем случае желаемым алгоритмом является загрузка фото, изменение его размера, применения фильтра и распечатка. В общем-то, это довольно простой прямолинейный алгоритм, но от этого он алгоритмом не перестаёт быть.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-28-Osnovy-programmirovaniya-Playground-chast-1/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Рассматриваемый нами язык Swift не многим отличается: пошаговый список шагов для компьютера. Тем не менее эти инструкции будут усложняться по мере чтения этой книги, хотя принцип будет не изменен: вы просто выдаете компьютеру последовательные команды.&lt;/p&gt;

&lt;p&gt;Каждый язык программирования это продвинутый и заранее проработанный способ построения таких инструкций. Компилятор же, в свою очередь, уже знает как интерпретировать написанный вами код, чтобы сделать из него ту же инструкцию для ЦП.&lt;/p&gt;

&lt;p&gt;Swift является крайне новаторским языком программирования. Он вобрал в себя достоинства многих других языков, а также исправил и использовал себе в угоду их недостатки. Пройдут годы, и мы будем смотреть на него, как на пережиток времени, однако, что же касается нынешнего момента, Swift – это довольно таки занимательный и быстро изменяющийся язык.&lt;/p&gt;

&lt;p&gt;Это был наш краткий вводный курс по теме “компьютерного железа”, систем счисления, кода и того, как они все вместе взаимодействуют с целью создания современных программ. На самом деле не малый объём информации для одной части. Пришло время узнать об инструментах, с помощью которых мы сможем реализовывать наш код, написанный на Swift.&lt;/p&gt;

&lt;p&gt;Данный текст является неавторизированным переводом книги &lt;a href=&quot;https://store.raywenderlich.com/products/ios-apprentice&quot;&gt;iOS Apprentice&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="code" /><category term="swift" /><summary type="html">В первой главе мы разберем основы. В начале вы узнаете о том, как работает код, а затем – об инструментах для написания это кода на базе языка программирования Swift.</summary></entry><entry><title type="html">Swift управление потоками Часть 3</title><link href="https://losthuman.ru/categories/code/2019/01/22/swift-flow-control-chast-3.html" rel="alternate" type="text/html" title="Swift управление потоками Часть 3" /><published>2019-01-22T00:00:00+05:00</published><updated>2019-01-22T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/22/Swift--Flow-Control--Chast-3</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/22/swift-flow-control-chast-3.html">&lt;p&gt;Приветствуем вас в третьей части нашей мини-серии по Swift, в которой вы узнаете как использовать булевые пеерменные и управлять потоками. Данный материал является переводом &lt;a href=&quot;https://www.raywenderlich.com/6366-swift-tutorial-part-3-flow-control&quot;&gt;tutorial&lt;/a&gt; с сайта &lt;a href=&quot;https://www.raywenderlich.com&quot;&gt;raywenderlich.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Это будет финальная часть мини-серии. Первые две части можно найти на нашем сайте: &lt;a href=&quot;https://losthuman.ru/categories/code/2018/10/07/swift-tipy-i-operatsii-chast-2.html&quot;&gt;Часть 1: Swift: выражения,переменные и константы.&lt;/a&gt; или &lt;a href=&quot;https://losthuman.ru/categories/code/2018/10/06/swift-uchebnik-chast-1-vyrazhenija.html&quot;&gt;Часть 2: Swift: Типы и операции&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;В терминологии компьютерного программирования возможность сказать компьютеру что делать в различных ситуациях называется управление потоками (control flow).&lt;/p&gt;

&lt;p&gt;В этой части мини-серии вы узнаете как принимать решения и повторять задачи в ваших программах используя синтаксис управления потоками. Вы также узнаете о булевых переменных, которые оперируют всего двумя значениями &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, а также как можно с их помощью сравнивать данные.&lt;/p&gt;

&lt;h2 id=&quot;с-чего-начать&quot;&gt;С чего начать&lt;/h2&gt;

&lt;p&gt;К этому моменту вы уже должны понимать что из себя представляют некоторые типы данных, например такие, как &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;. Сейчас вы познакомитесь с другим типом данных, который позволит вам сравнивать значения применяя операторы сравнения.&lt;/p&gt;

&lt;p&gt;Когда выполняется сравнение, например поиск большего из двух чисел, ответ представляет собой либо &lt;em&gt;правда&lt;/em&gt; , либо &lt;em&gt;ложь&lt;/em&gt;. Swift имеет тип данных специально предназначенный для таких целей. Он называется &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt;, что является сокращением от слова Boolean. Само понятие булевого числа было введено в математику Джорджем Булем, предложившим концепцию  &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Вот как используются Boolean в Swift:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let yes = true // Подразуемвается что это тип Bool
let no = false // Подразуемвается что это тип Bool
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вообще говоря, булевая пеерменная может иметь только два значения: &lt;code class=&quot;highlighter-rouge&quot;&gt;правда&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;ложь&lt;/code&gt;, которые обозначаются ключевыми словами &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, соответственно. В примере выше использовались эти ключевые слова для присвоения значения константам.&lt;/p&gt;

&lt;h3 id=&quot;булевые-операторы&quot;&gt;Булевые операторы&lt;/h3&gt;

&lt;p&gt;Булевый тип данных в основном используется для сравнения значений. Например, у вас есть два значения и вы хотите знать равны ли они между собой: либо эти значения равны (true), либо они различны (false).&lt;/p&gt;

&lt;p&gt;В Swift вы можете выполнить это используя оператор равенства, который обозначается &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let doesOneEqualTwo = (1 == 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Swift подразумевает, что &lt;code class=&quot;highlighter-rouge&quot;&gt;doesOneEqualTwo&lt;/code&gt; это тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt;. Совершенно очевидно, что 1 не равно 2 и поэтому,&lt;code class=&quot;highlighter-rouge&quot;&gt;doesOneEqualTwo&lt;/code&gt; будет присвоено значение &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Аналогично, если два числа &lt;em&gt;не&lt;/em&gt; равны можно использовать оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let doesOneNotEqualTwo = (1 != 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом случае сравнение будет &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, так как 1 не равно 2, поэтому &lt;code class=&quot;highlighter-rouge&quot;&gt;doesOneNotEqualTwo&lt;/code&gt; будет присвоено значение &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Префикс оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; также называемый оператор отрицания, переключает &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, а &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. То же самое можно записать иначе:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let alsoTrue = !(1 == 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Рассмотрим это выражение шаг за шагом: 1 не равно 2, поэтому (1 == 2) это &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; и тогда &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; переключает &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Еще два оператора позволят вам определить если число больше чем (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;) или меньше чем (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;) другое число. Совершенно точно, что вы знакомы с этими оперторами из школьного курса математики.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let isOneGreaterThanTwo = (1 &amp;gt; 2)
let isOneLessThanTwo = (1 &amp;lt; 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это не наука о космических ракетах, поэтому каждому будет понятно, что константа &lt;code class=&quot;highlighter-rouge&quot;&gt;isOneGreaterThanTwo&lt;/code&gt; будет равна &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, а константа &lt;code class=&quot;highlighter-rouge&quot;&gt;isOneLessThanTwo&lt;/code&gt; будет равна&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Есть еще оператор, который позволяет проверять если значение меньше &lt;em&gt;или&lt;/em&gt; равно другому значению: &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;. Это комбинация &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;, и поэтому она возвращает &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; если первое значение либо меньеше, чем второе значение, либо равно ему.&lt;/p&gt;

&lt;p&gt;Аналогично работает оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;, которые позволяет выполнить проверку является ли значение больше или меньше другого.&lt;/p&gt;

&lt;h3 id=&quot;булевая-логика&quot;&gt;Булевая логика&lt;/h3&gt;

&lt;p&gt;Примеры выше проверяют выполнение только одного условия. Для того, чтобы получить результат проверки выполнения нескольких объединенных условий следует применить булеву логику.&lt;/p&gt;

&lt;p&gt;Одним из способов объединения условий является использование оператора AND. Когда вы используете AND вместе с булевыми значениями, результатом будет другое булевое значение. Если оба входящих булевых значения &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, тогда результатом будет другое булевое значение &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. В противном случае результатом будет &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/george_boole-650x480.png&quot; alt=&quot;george_boole&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В Swift булевый оператор AND обозначается как &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let and = true &amp;amp;&amp;amp; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом случае &lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt; будет присвоено значение &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Если бы любое значение справа было &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;,тогда &lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt; было бы присвоено значение &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Другой способ объединения условий это использование оператора OR. Когда вы используете  OR вместе с двумя булевыми значениями, результат будет &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, если &lt;em&gt;один&lt;/em&gt; из входящих булевых значений является &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Только если &lt;em&gt;оба&lt;/em&gt; входящих значения являются &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, результат будее тоже &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;В Swift булевый оператор OR обозначается как &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let or = true || false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом случае &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; будет &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Если оба значения справа были  &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, тогда значение&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; было бы &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;. Если бы оба значения были &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, тогда значение &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; стало бы&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;В Swift булевая логика обычно применяется к нескольким условиям. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let andTrue = 1 &amp;lt; 2 &amp;amp;&amp;amp; 4 &amp;gt; 3
let andFalse = 1 &amp;lt; 2 &amp;amp;&amp;amp; 3 &amp;gt; 4

let orTrue = 1 &amp;lt; 2 || 3 &amp;gt; 4
let orFalse = 1 == 2 || 3 == 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Каждая из этих проверок предусматривает два различных условия, объединенных либо оператором  AND, либо оператором OR.&lt;/p&gt;

&lt;p&gt;Также допускается использовать булевую логику для объединения более чем двух условий. Например вы можете формировать сравнения так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let andOr = (1 &amp;lt; 2 &amp;amp;&amp;amp; 3 &amp;gt; 4) || 1 &amp;lt; 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда вы заключаете скобками часть выражения, вы определяете порядок его выполнения. Вначале, Swift выполнит выражение внутри скобок, а затем выполнит все выражение целиком:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. (1 &amp;lt; 2 &amp;amp;&amp;amp; 3 &amp;gt; 4) || 1 &amp;lt; 4
2. (true &amp;amp;&amp;amp; false) || true
3. false || true
4. true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;равенство-строк&quot;&gt;Равенство строк&lt;/h3&gt;

&lt;p&gt;Иногда вы хотите определит равны ли две строки друг другу. Например, задачей в детской игре может быть правильное определение названий животных, изображенных на фотографиях.&lt;/p&gt;

&lt;p&gt;В Swift вы можете сравнивать строки используя стандартный оператор равенства &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;, точно таким же способом каким мы ранее сравнивали числа. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let guess = &quot;dog&quot;
let dogEqualsCat = guess == &quot;cat&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dogEqualsCat&lt;/code&gt; имеет булевое значение, которое в данном случае равно &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, потому, что слово &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;dog&quot;&lt;/code&gt; не равно слову &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cat&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Точно так же как и с числами, вы можете сравнивать не только равны ли строки, но также определять больше одна из строк или меньше, чем другая. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let order = &quot;cat&quot; &amp;lt; &quot;dog&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Такой сиснтаксис проверит если одна из строк находится ранее другой в алфавитном порядке. В этом случае значение &lt;code class=&quot;highlighter-rouge&quot;&gt;order&lt;/code&gt; равно &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; потому, что  &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cat&quot;&lt;/code&gt; по алфавиту находится до &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;dog&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;условный-оператор-if&quot;&gt;Условный оператор if&lt;/h2&gt;

&lt;p&gt;Первый и самый общий способ контроля потока в программе это использование условного оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; (или выражения &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;), который позволяет программе делать что-то только &lt;em&gt;если&lt;/em&gt; выполняется определенное условие как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Например, рассмотрим следующий пример:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 2 &amp;gt; 1 {
  print(&quot;Yes, 2 is greater than 1.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это самый  простой пример использования оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;. Если условие выполняется как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, тогда оператор будет выполнять код между фигурными скобками. Если условие выполняется как &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, тогда оператор не будет выполнять код между фигурными скобками.&lt;/p&gt;

&lt;p&gt;Вы можете изменить оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; включив в него возможность выполнения кода, если условие ыполняется как &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;. Для этого используется оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let animal = &quot;Fox&quot;
if animal == &quot;Cat&quot; || animal == &quot;Dog&quot; {
  print(&quot;Animal is a house pet.&quot;)
} else {
  print(&quot;Animal is not a house pet.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном случае если значение &lt;code class=&quot;highlighter-rouge&quot;&gt;animal&lt;/code&gt; равно либо &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Cat&quot;&lt;/code&gt; либо &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Dog&quot;&lt;/code&gt;, тогда оператор выполнит первый блок кодв. Если  значение&lt;code class=&quot;highlighter-rouge&quot;&gt;animal&lt;/code&gt; не равно &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Cat&quot;&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Dog&quot;&lt;/code&gt;, тогда оператор выполнит блок кода, заключенный внутри &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;, напечатав следующее в дебаггере:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Animal is not a house pet.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но, с условным оператором &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; вы можете еще больше, чем в предыдущем примере. Иногда вы хотите проверить одно условие, на соответстиве нескольким. Для этого используется оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;else-if&lt;/code&gt;, с помощью которого можно вложить еще один оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; в оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;, относящийся к предыдущему условному оператору &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Например, можно записать код так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let hourOfDay = 12
var timeOfDay = &quot;&quot;

if hourOfDay &amp;lt; 6 {
  timeOfDay = &quot;Early morning&quot;
} else if hourOfDay &amp;lt; 12 {
  timeOfDay = &quot;Morning&quot;
} else if hourOfDay &amp;lt; 17 {
  timeOfDay = &quot;Afternoon&quot;
} else if hourOfDay &amp;lt; 20 {
  timeOfDay = &quot;Evening&quot;
} else if hourOfDay &amp;lt; 24 {
  timeOfDay = &quot;Late evening&quot;
} else {
  timeOfDay = &quot;INVALID HOUR!&quot;
}
print(timeOfDay)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном случае вложенные операторы &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; проверяют условия одно за другим, пока одно из них не выполнится как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Только код, связанный с этим условием будет выполнен, независимо от того могут ли последующие условия &lt;code class=&quot;highlighter-rouge&quot;&gt;else-if&lt;/code&gt;выполниться как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Иными словам порядок проверки условий имеет значение!&lt;/p&gt;

&lt;p&gt;Вы можете добавить условный оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;в конец для обработки случая, когда ни одно из условий не выполняется как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. В таком случае использование &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; является опциональным, если вы не нуждаетесь в нем. В использованном примере необходимо, чтобы переменная &lt;code class=&quot;highlighter-rouge&quot;&gt;timeOfDay&lt;/code&gt; имела валидное значение времени, когда вы будете распечатывать его значение.&lt;/p&gt;

&lt;p&gt;В этом прмиере условный оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; получает время, выраженное в часах (числах) и конвертирует его в строку, представляющую описание времени дня, к которому  это время относится. Работая с 24-х часовым форматом времени условный оператор проверяет последовательно одно услвоие за другим.&lt;/p&gt;

&lt;p&gt;В коде выше  переменная &lt;code class=&quot;highlighter-rouge&quot;&gt;hourOfDay&lt;/code&gt; имеет значение &lt;code class=&quot;highlighter-rouge&quot;&gt;12&lt;/code&gt;. Поэтому, код будет печатать следующее сообщение:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Afternoon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обратите внимание, что, хотя еще два условия &lt;code class=&quot;highlighter-rouge&quot;&gt;hourOfDay &amp;lt; 20&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;hourOfDay &amp;lt; 24&lt;/code&gt; также выполняются как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, условный оператор выполнит только первый блок, чье условие соответствут &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. В этом случае, выполнится блок с условием &lt;code class=&quot;highlighter-rouge&quot;&gt;hourOfDay &amp;lt; 17&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;инкапсуляция-переменных&quot;&gt;Инкапсуляция переменных&lt;/h3&gt;

&lt;p&gt;Условный оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; описывает новую концепцию пространства, которая является способом инкапсуляции переменных с помощью фигурных скобок.&lt;/p&gt;

&lt;p&gt;Вообразите, что вы хотите подсчитать комиссию, которую взимает ваш клиент. Вот сделка, которую вы заключили:&lt;/p&gt;

&lt;p&gt;Вы зарабатываете 25 долларов в час за 40 часов, и 50 долларов за каждый час сверх этого времени.&lt;/p&gt;

&lt;p&gt;Используя Swift вы можете расчитать ваши платежи:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var hoursWorked = 45

var price = 0
if hoursWorked &amp;gt; 40 {
  let hoursOver40 = hoursWorked - 40
  price += hoursOver40 * 50
  hoursWorked -= hoursOver40
}
price += hoursWorked * 25

print(price)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Этот код получает количество часов и проверяет, превышает ли это число 40 часов. Если это так, код считает количество часов сверх 40 и умножает его на 50 долларов, затем добавляет результат к цене. Далее код вычитает количество часов превышающих 40 из отработанных часов. Осташееся время умножается на 25 долларов и добавляется к цене.&lt;/p&gt;

&lt;p&gt;В примере выше результата должен быть следующим:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1250
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hoursOver40&lt;/code&gt; объявляет новую константу, которую можно использовать внутри оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;. Но, что случится, если вы попробуете использовать ее в конце кода, за пределами оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ...

print(price)
print(hoursOver40)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Результат будет следующим:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: MyPlayground.playground:8:7: error: use of unresolved identifier 'hoursOver40'
print(hoursOver40)
  ^~~~~~~~~~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта ошибка информирует вас что вы можете использовать константу &lt;code class=&quot;highlighter-rouge&quot;&gt;hoursOver40&lt;/code&gt; в пространстве, в котором эта константа была объявлена (создана). В этом случае, условный оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; создает новое пространство, так, что когда это пространство заканчивается, вы не можете больше испоьзовать эту константу.&lt;/p&gt;

&lt;p&gt;В любом случае, каждое пространство может использовать переменные и константы объявленные в своем родительством пространстве. В примере выше пространство внутри оператора  &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; использует переменные &lt;code class=&quot;highlighter-rouge&quot;&gt;price&lt;/code&gt; и  &lt;code class=&quot;highlighter-rouge&quot;&gt;hoursWorked&lt;/code&gt;, которые были созданы в родительском пространстве.&lt;/p&gt;

&lt;h3 id=&quot;тернарный-условный-оператор&quot;&gt;Тернарный условный оператор&lt;/h3&gt;

&lt;p&gt;Тернарный условный оператор получает условие и возвращает одно из двух значений, в зависимости от того, что было результатом выполнения условия: &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(&amp;lt;CONDITION&amp;gt;) ? &amp;lt;TRUE VALUE&amp;gt; : &amp;lt;FALSE VALUE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Рассмотрим пример в котором надо определить минимальное из двух переменных:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = 5
let b = 10

let min: Int
if a &amp;lt; b {
  min = a
} else {
  min = b
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Благодаря тернарному оператору вы можете переписать этот код по-другому:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = 5
let b = 10

let min = a &amp;lt; b ? a : b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если условие &lt;code class=&quot;highlighter-rouge&quot;&gt;a &amp;lt; b&lt;/code&gt; является &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, тогда результатом будет присвоение  константе &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;
значения &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;; если  &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, то результатом будет значение &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Тернарный оператор следует применять с осторожностью. Его краткость может стать причиной написания трудночитаемого кода.&lt;/p&gt;

&lt;h2 id=&quot;циклы&quot;&gt;Циклы&lt;/h2&gt;

&lt;p&gt;Циклы это способ выполнять код многократно. В самом начале этого раздела вы узнаете о цикле &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;циклы-while&quot;&gt;Циклы While&lt;/h3&gt;

&lt;p&gt;Цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; повторяет блок кода пока некоторое условие выполняется как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; создается следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while &amp;lt;CONDITION&amp;gt; {
  &amp;lt;LOOP CODE&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во время каждой итерации цикл проверяет выполнение условия. Если условие выполняется как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, тогда цикл выполняется и переходит к следующей итерации. Если условие выполняется, как &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, тогда цикл останавливается, Также, как и условный оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;, цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; создает пространство.&lt;/p&gt;

&lt;p&gt;Простейший цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while true {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Этот цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;, который никогда не закончится, потому, что условие всегда будет &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Бесконечный цикл может не стать причиной падения вашей программы, но это может с высокой вероятностью “повесить” ваш компьютер.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-force-quit.png&quot;&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-force-quit-500x500.png&quot; alt=&quot;Force quit&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Вот более реальный пример цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sum = 1

while sum &amp;lt; 1000 {
  sum = sum + (sum + 1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Этот код расчитывает математическую последовательность, пределом которой является значение больше, чем 1000.&lt;/p&gt;

&lt;p&gt;Цикл выполняется следующим образом:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-while-loop-iteration.png&quot;&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-while-loop-iteration-560x500.png&quot; alt=&quot;While Loop iteration&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;После девяти итераций значение переменой &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; станет равно&lt;code class=&quot;highlighter-rouge&quot;&gt;1023&lt;/code&gt;, поэтому условие выполнения цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;sum &amp;lt; 1000&lt;/code&gt; станет &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;. После этого выполнение цикла остановится.&lt;/p&gt;

&lt;h3 id=&quot;циклы-repeat-while&quot;&gt;Циклы Repeat-while&lt;/h3&gt;

&lt;p&gt;Это вариант цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;названный цикл repeat-while. Отличие от цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; состоит в том, что условие выполнения цикла оценивается &lt;em&gt;в конце&lt;/em&gt; выполнения цикла, а не в начале.&lt;/p&gt;

&lt;p&gt;Цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;repeat-while&lt;/code&gt; конструируется следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;repeat {
  &amp;lt;LOOP CODE&amp;gt;
} while &amp;lt;CONDITION&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вот предыдущий пример, но с сипользованием цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;repeat-while&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 1

repeat {
  sum = sum + (sum + 1)
} while sum &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом примере результат будет точно такой-же. При этом, такое совпадение может быть не всегда.&lt;/p&gt;

&lt;p&gt;Рассмотрим следующий пример выполнения цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 1

while sum &amp;lt; 1 {
  sum = sum + (sum + 1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А сейчас рассмотрим соответствующий цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;repeat-while&lt;/code&gt;, который использует для выполнения точно такое-же условие:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 1

repeat {
  sum = sum + (sum + 1)
} while sum &amp;lt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В  случае с регулярным цикло &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;, условие &lt;code class=&quot;highlighter-rouge&quot;&gt;sum &amp;lt; 1&lt;/code&gt; равна &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; будет выполнено сразу на старте цикла, Это значит, что код в теле цикла не будет выполнен. Значение переменной &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; будет равно &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; потому, что цикл не будет выполнен ни разу.&lt;/p&gt;

&lt;p&gt;В случае же с циклом &lt;code class=&quot;highlighter-rouge&quot;&gt;repeat-while&lt;/code&gt;, переменная &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; будет равна &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;, потому, что цикл будет выполнен один раз.&lt;/p&gt;

&lt;h3 id=&quot;прерывание-цикла&quot;&gt;Прерывание цикла&lt;/h3&gt;

&lt;p&gt;Иногда вы хотите прервать цикл ранее, чем он будет закончен. Вы можете использовать для этого выражение &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt;, которое немедлено остановит выполнение цикла и продолжит выполнение кода после цикла.&lt;/p&gt;

&lt;p&gt;Например, рассмотрим следующий код:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 1

while true {
  sum = sum + (sum + 1)
  if sum &amp;gt;= 1000 {
    break
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом примере условие выполнения цикла равно &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, так что цикл может выполняться бесконечно. Однако, наличие выражения &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt; означает, что цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; будет остановлен как только значение &lt;code class=&quot;highlighter-rouge&quot;&gt;sum &lt;/code&gt; станет больше или равно &lt;code class=&quot;highlighter-rouge&quot;&gt;1000&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;продвинутое-управление-потоками&quot;&gt;Продвинутое управление потоками&lt;/h2&gt;

&lt;p&gt;В этом разделе вы продолжите знакомиться с тем, как контролировать выполнение потока. Вы узнаете о цикле, который называется цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;диапазоны&quot;&gt;Диапазоны&lt;/h2&gt;

&lt;p&gt;До того, как погрузиться в изучение цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;, вам необходимо знать о &lt;a href=&quot;https://developer.apple.com/documentation/swift/closedrange&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ClosedRange&lt;/code&gt; - закрытом диапазоне&lt;/a&gt;
and &lt;a href=&quot;https://developer.apple.com/documentation/swift/range&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Range&lt;/code&gt;  - полуоткрытом диапазоне&lt;/a&gt; типах, которые позволяют представлять последовательности чисел.&lt;/p&gt;

&lt;p&gt;Во-первых, существуют закрытые диапазоны:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let closedRange = 0...5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Три точки (&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;) сигнализируют что этот диапазон закрытый, что означает диапазон числе от 0 до 5, включая 0 и 5: &lt;code class=&quot;highlighter-rouge&quot;&gt;(0, 1, 2, 3, 4, 5)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Во-вторых, существуют полуоткрытые диапазоны:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let halfOpenRange = 0..&amp;lt;5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом случае заменим три точки на две точки и знак меньше (&lt;code class=&quot;highlighter-rouge&quot;&gt;..&amp;lt;&lt;/code&gt;). Полуоткрытый диапазон значит диапазон от 0 до 5, включая 0, но &lt;em&gt;не&lt;/em&gt; включая 5: &lt;code class=&quot;highlighter-rouge&quot;&gt;(0, 1, 2, 3, 4)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Оба закрытый и полуоткрытый диапазоны должны всегда быть возрастающими. Другими словами, второе число диапазона должно быть всегда больше или равно первому.&lt;/p&gt;

&lt;p&gt;Диапазоны обычно используют для циклов &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; и выражения &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;цикл-for&quot;&gt;Цикл For&lt;/h2&gt;

&lt;p&gt;Теперь, когда вы знаете немного о диапазонах, самое время взглянуть на цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;. Этот цикл используется для выполнения кода определенное число раз.&lt;/p&gt;

&lt;p&gt;Конструкция цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; выглядит так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for &amp;lt;CONSTANT&amp;gt; in &amp;lt;RANGE&amp;gt; {
  &amp;lt;LOOP CODE&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; начинается со слова &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;. Далее последовательно указываются: имя константы, слово  &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; и диапазон повторений цикла. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let count = 10
var sum = 0

for i in 1...count {
  sum += i
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; выполняется в диапазоне от 1 до значения константы &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;. В первом выполнении цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; будет равно первому элементу диапазона - 1. На каждом повторении &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; будет увеличиваться на единицу, до тех пор, пока не будет равной &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;, после чего цикл будет выполнен последний раз.&lt;/p&gt;

&lt;p&gt;Если вы используете полуоткрытый диапазон, последняя итерация будет при значении &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; равном &lt;code class=&quot;highlighter-rouge&quot;&gt;count - 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Внутри цикла  вы добавляете &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; к переменной &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;. Эта операция повторяется 10 раз , таким образом выполняется последовательно сложение &lt;code class=&quot;highlighter-rouge&quot;&gt;1 + 2 + 3 + 4 + 5 + ...&lt;/code&gt; до тех пор пока &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; не будет равно 10.&lt;/p&gt;

&lt;p&gt;На рисунке ниже изображены значения константы &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; и переменной &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; для каждой итерации:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-part-3-for-loop-iteration.png&quot; alt=&quot;Итерации цикла for&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Константа &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; видима только внутри пространства цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;, что значит, что эта константа не доступна за пределами цикла.&lt;/p&gt;

&lt;p&gt;В случае, если вы не хотите использовать в цикле константы вовсе, вы можете использовать знак нижнего подчеркивания (_) для укзания что игнооируете ее (константу). Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 1
var lastSum = 0

for _ in 0..&amp;lt;count {
  let temp = sum
  sum = sum + lastSum
  lastSum = temp
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Этот код не имеет константы в цикле, цикл просто выполняется определенное число раз. В этом случае диапазон начинается от 0 и заканчивается значением &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;, при этом диапазон полуоткрытый. Таким способом обычно записываются циклы, которые выполняются определенное число раз.&lt;/p&gt;

&lt;p&gt;Также возможно выполнить только те итерации, которые соответствуют определнному условию. Например, представим, что вы хотите вычислить сумму только нечетных чисел:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sum = 0
for i in 1...count where i % 2 == 1 {
  sum += i
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Цикл выше содержит оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt;. Благодаря этому цикл будет выполнять код в диапазоне от 1 до &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;, но только в том случае, когда условие предусмотренное &lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt; будет &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. В этом случае это будет, когда значение &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; является нечетным числом.&lt;/p&gt;

&lt;h3 id=&quot;оператор-continue&quot;&gt;Оператор Continue&lt;/h3&gt;

&lt;p&gt;Иногда вым может понадобится пропустить итерацию цикла в определенном случае, без прерывания самого цикла целиком. Вы можете сделать это с помощью оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt;, который немедленно закончит текущую итерацию и перейдет к следующей.&lt;/p&gt;

&lt;p&gt;Использование &lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; вместо простого &lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt; предпочтительнее, когда вам необходим высокоуровневый контроль над исполнением кода.&lt;/p&gt;

&lt;p&gt;Например рассмотрим сетку 8х8, в которой каждая ячейка содержит значение номера ряда умноженого на колонку:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/full_board-496x500.png&quot; alt=&quot;full_board&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Это очень похоже на таблицу умножения, не правда ли?&lt;/p&gt;

&lt;p&gt;Скажем, вы хотите расчитать сумму всех ячеек за исключением тех, которые расположены на четных рядах:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/first_board_example-496x500.png&quot; alt=&quot;first_board_example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;С помощью цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; эту задачу можно решить следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 0

for row in 0..&amp;lt;8 {
  if row % 2 == 0 {
    continue
  }

  for column in 0..&amp;lt;8 {
    sum += row * column
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда остаток от деления номера ряда на 2 равен 0, тогда этот ряд четный. В этом случае  &lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; заставит цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; перепрыгнуть на следующий ряд.&lt;/p&gt;

&lt;p&gt;Также, как и &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; работает с обоими циклами - &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;оператор-switch&quot;&gt;Оператор Switch&lt;/h2&gt;

&lt;p&gt;Еще один способ управления потоками осуществляется через использование оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;, который позволяет вам выполнять различные части кода в зависимости от значение переменной или константы.&lt;/p&gt;

&lt;p&gt;Вот очень простой оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;, который обрабатывает целые числа:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let number = 10

switch number {
case 0:
  print(&quot;Zero&quot;)
default:
  print(&quot;Non-zero&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После выполнение кода в консоли будет напечатано:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Non-zero
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Целью оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; было определение является ли число нулем.&lt;/p&gt;

&lt;p&gt;Для обработки конкрентного значения вы используете &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;, представляющее значение, которое вы хотите сравнить с получаемым значением, в даном случае это &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;. Также вы используете &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;, чтобы назначить действие, если оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; получит любое другое число, отличное от 0.&lt;/p&gt;

&lt;p&gt;Вот другой пример использования &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch number {
case 10:
  print(&quot;It's ten!&quot;)
default:
  break
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом примере вы проверяете является ли значение переменной или константы равным 10, и, если это так, в консоли выводится соответствующее сообщение. Для значений, отличных от 10 никаких действий не предусмотрено. Когда вы не хотите выполнения какого-либо действия, или вы хотите определить дефолтное состояние для выполнения кода, можно использовать оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt;. Это подскажет Swift’у что вы не написали здесь никакго кода и никаких действий выполняться не будет. &lt;code class=&quot;highlighter-rouge&quot;&gt;сase&lt;/code&gt; никогда не должен оставаться пустым, поэтому необходимо писать код, даже если этим кодом будет оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;Оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; работает с любыми типами данных! Вот пример обработки для строк:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let string = &quot;Dog&quot;

switch string {
case &quot;Cat&quot;, &quot;Dog&quot;:
  print(&quot;Animal is a house pet.&quot;)
default:
  print(&quot;Animal is not a house pet.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После выполнения кода в консоле появится сообщение:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Animal is a house pet.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом примере, вы передаете два значения для одного оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;, поэтому код будет выполняться в случае, если переданое значение будет либо &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Cat&quot;&lt;/code&gt;, либо &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Dog&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;продвинутые-действия-с-оператором-switch&quot;&gt;Продвинутые действия с оператором Switch&lt;/h3&gt;

&lt;p&gt;Вы можете также передать вашему оператору &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; более, чем один &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;. В предыдущем разделе вы видели, что оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; использует множество вложенных операторов &lt;code class=&quot;highlighter-rouge&quot;&gt;else-if&lt;/code&gt; для конвертирования времени. Вы можете переписать это более кратко, с использванием оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let hourOfDay = 12
var timeOfDay = &quot;&quot;

switch hourOfDay {
case 0, 1, 2, 3, 4, 5:
  timeOfDay = &quot;Early morning&quot;
case 6, 7, 8, 9, 10, 11:
  timeOfDay = &quot;Morning&quot;
case 12, 13, 14, 15, 16:
  timeOfDay = &quot;Afternoon&quot;
case 17, 18, 19:
  timeOfDay = &quot;Evening&quot;
case 20, 21, 22, 23:
  timeOfDay = &quot;Late evening&quot;
default:
  timeOfDay = &quot;INVALID HOUR!&quot;
}

print(timeOfDay)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выполнение этого кода выведет в консоль сообщение:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Afternoon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Помните диапазоны? Вы можете использовать диапазоны в операторе &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;. Можно переписать этот код еще более кратко:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var timeOfDay2 = &quot;&quot;

switch hourOfDay {
case 0...5:
  timeOfDay2 = &quot;Early morning&quot;
case 6...11:
  timeOfDay2 = &quot;Morning&quot;
case 12...16:
  timeOfDay2 = &quot;Afternoon&quot;
case 17...19:
  timeOfDay2 = &quot;Evening&quot;
case 20..&amp;lt;24:
  timeOfDay2 = &quot;Late evening&quot;
default:
  timeOfDay2 = &quot;INVALID HOUR!&quot;
}

print(timeOfDay2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Также можно сопоставлять условия, основанные на свойствах значения. Как вы узнали ранее в первой части этой серии, вы можете использовать оператор модуль для определения является ли целое число четным или нечетным. Например так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch number {
case let x where x % 2 == 0:
  print(&quot;Even&quot;)
default:
  print(&quot;Odd&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выполнение этого кода выведет в консоль сообщение:&lt;/p&gt;

&lt;p&gt;Even&lt;/p&gt;

&lt;p&gt;Оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; использует синаксис &lt;code class=&quot;highlighter-rouge&quot;&gt;let-where&lt;/code&gt;, который означает, что &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; будет выполненен только если определенное условие будет выполняться как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Часть синтаксиса &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; связывает значение и имя, в то время как оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt; обеспечивает булевое условие, которое должно выполняться как &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; для выполнения &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;. В этом примере  &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; выполняется в случае, если значение четное, т.е. если значение остатка от деления на 2 равно 0.&lt;/p&gt;

&lt;p&gt;Этот метод, с помощью которого вы можете сравнивать числа еще называют паттерн сравнения.&lt;/p&gt;

&lt;p&gt;В предыдущем примере была использована в общем-то ненужная константа &lt;code class=&quot;highlighter-rouge&quot;&gt;х&lt;/code&gt;, фактически это еще одно наименование для &lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;. Вы можете использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt; в конструкции &lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt;и заменить константу &lt;code class=&quot;highlighter-rouge&quot;&gt;х&lt;/code&gt; на знак нижнего подчеркивания.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch number {
case _ where number % 2 == 0:
  print(&quot;Even&quot;)
default:
  print(&quot;Odd&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;частичное-сравнивание&quot;&gt;Частичное сравнивание&lt;/h3&gt;

&lt;p&gt;Другой способ, в котором вы можете очень эффективно использовать оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;для сравнения выглядит следующим образо:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinates = (x: 3, y: 2, z: 5)

switch coordinates {
case (0, 0, 0): // 1
  print(&quot;Origin&quot;)
case (_, 0, 0): // 2
  print(&quot;On the x-axis.&quot;)
case (0, _, 0): // 3
  print(&quot;On the y-axis.&quot;)
case (0, 0, _): // 4
  print(&quot;On the z-axis.&quot;)
default:        // 5
  print(&quot;Somewhere in space&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Этот оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; использует частичное сравнивание. Вот что происходит в коде, по-порядку:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Точное соответствие &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; в котором значение &lt;code class=&quot;highlighter-rouge&quot;&gt;(0, 0, 0)&lt;/code&gt;. Это центр 3D координат.&lt;/li&gt;
  &lt;li&gt;Совпадение y=0, z=0 и любое значение x. Это координата по оси х.&lt;/li&gt;
  &lt;li&gt;Совпадение x=0, z=0 и любое значение y. Это координата по оси y.&lt;/li&gt;
  &lt;li&gt;Совпадение x=0, y=0 и любое значение z. Это координата по оси z.&lt;/li&gt;
  &lt;li&gt;Совпадение  с остальными координатами.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;В данном примере используется знак нижнего подчеркивания потому, что нет особой необходимости в том, чтобы указывать наименование константы. Если же такая необходимость существует, то можно переписать код следующим образом.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch coordinates {
case (0, 0, 0):
  print(&quot;Origin&quot;)
case (let x, 0, 0):
  print(&quot;On the x-axis at x = \(x)&quot;)
case (0, let y, 0):
  print(&quot;On the y-axis at y = \(y)&quot;)
case (0, 0, let z):
  print(&quot;On the z-axis at z = \(z)&quot;)
case let (x, y, z):
  print(&quot;Somewhere in space at x = \(x), y = \(y), z = \(z)&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном случае используется синтаксис &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; для извлечения соответствующих значений. Затем в консоле выводится значение с помощью строковой интерполяции.&lt;/p&gt;

&lt;p&gt;Обратите внимание на то, что в данном случае отсутствует дефолтное значение для оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;. Это потому, что последний &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; по сути является тем самым дефолтным значением. Он соответствуетлюбому значениям, которые не соответствуют предыдущим &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;ам. В &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; нет необходимости в определении значения дефолтного &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt;, если предусмотрены все возможные значения.&lt;/p&gt;

&lt;p&gt;Также стоит обратить внимание на то, что правила синстаксиса позволяют указывать один оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; для всех связанных значений кортежа: &lt;code class=&quot;highlighter-rouge&quot;&gt;let (x, y, z)&lt;/code&gt; это то же самое, что &lt;code class=&quot;highlighter-rouge&quot;&gt;(let x, let y, let z)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Таким образом, можно, используя тот же самый синтаксис &lt;code class=&quot;highlighter-rouge&quot;&gt;let-where&lt;/code&gt;, записать код с более комплексным решением, например так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch coordinates {
case let (x, y, _) where y == x:
  print(&quot;Along the y = x line.&quot;)
case let (x, y, _) where y == x * x:
  print(&quot;Along the y = x^2 line.&quot;)
default:
  break
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как вы видите в данном случае сравнивается  “y равный x” и “y равный квадрату x”.&lt;/p&gt;

&lt;p&gt;На этом мини-серия по Swift закончена. Желаем Вам успехов в изучении этого замечательного языка.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/6366-swift-tutorial-part-3-flow-control&quot;&gt;Источник&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="swift" /><category term="programming" /><summary type="html">Приветствуем вас в третьей части нашей мини-серии по Swift, в которой вы узнаете как использовать булевые пеерменные и управлять потоками. Данный материал является переводом tutorial с сайта raywenderlich.com.</summary></entry><entry><title type="html">NPM подсказки и советы для начинающих</title><link href="https://losthuman.ru/categories/code/2019/01/06/npm-sovety-i-trjuki.html" rel="alternate" type="text/html" title="NPM подсказки и советы для начинающих" /><published>2019-01-06T00:00:00+05:00</published><updated>2019-01-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2019/01/06/NPM-sovety-i-trjuki</id><content type="html" xml:base="https://losthuman.ru/categories/code/2019/01/06/npm-sovety-i-trjuki.html">&lt;p&gt;Если вы ежедневно используете NPM в своей работе, то скорее всего вы по достоинству оцените эти подсказки и советы.&lt;/p&gt;

&lt;h2 id=&quot;создание-файла-packagejson&quot;&gt;Создание файла package.json&lt;/h2&gt;

&lt;p&gt;В этом случае мы обычно используем команду &lt;code class=&quot;highlighter-rouge&quot;&gt;npm init&lt;/code&gt; и затем добавляем информацию, которую запрашивает npm. Но, если в некоторых случаях нет никакой необходимости заботиться о том, какая информация будет в файле package.json и возможно использовать дефолтные значения для проекта, то мы просто нажимаем enter вместо того, чтобы отвечать на вопросы npm. Чтобы не терять время на это можно просто добавить &lt;code class=&quot;highlighter-rouge&quot;&gt;-y&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;--yes&lt;/code&gt; к команде &lt;code class=&quot;highlighter-rouge&quot;&gt;npm init&lt;/code&gt;. В этом случае package.json будет создан с дефолтными настройками без дополнительных вопросов.&lt;/p&gt;

&lt;h2 id=&quot;установка-модулей&quot;&gt;Установка модулей&lt;/h2&gt;

&lt;p&gt;Вместо &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; можно использовать упрощенный вариант &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;установка-нескольких-модулей-за-один-раз&quot;&gt;Установка нескольких модулей за один раз&lt;/h2&gt;

&lt;p&gt;Вместо использования команды &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; для каждого модуля, как например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp-pug  
npm i gulp-debug  
npm i gulp-sass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Можно одной командой инсталировать все модули сразу:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp-pug gulp-debug gulp-sass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Еще проще сожно установить нескольуо модулей за один раз, если их названия начинаются с одного и того же сочетания букв:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp{-debug,-sass,-pug}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;использования-установочных-флагов&quot;&gt;Использования установочных флагов&lt;/h2&gt;

&lt;p&gt;Если вы хотите установить пакет и сохранить его в production зависимостях, то обычно это делается следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp --save-prod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но, также можно использовать флаг  &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp -P
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;То же самое справедливо для development зависимостей, вместо &lt;code class=&quot;highlighter-rouge&quot;&gt;--save-dev&lt;/code&gt; можно использовать флаг &lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i gulp -D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;По умолчанию, когда вы запускаете команду &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; без флагов, npm добавит устанавливаемый пакет в зависимости вашего файла package.json. Если вы хотите предотвратить это, то используйте флаг &lt;code class=&quot;highlighter-rouge&quot;&gt;--no-save&lt;/code&gt; при установке такого пакета:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i vue --no-save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;информация-о-пакетах&quot;&gt;Информация о пакетах&lt;/h2&gt;

&lt;p&gt;Следующие команды покажут вам информацию относящуюся к пакету vue:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm view vue&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;npm v vue&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-06-NPM-sovety-i-trjuki/2.png&quot; alt=&quot;&quot; /&gt;Результат выполнения комманды npm view&lt;/p&gt;

&lt;p&gt;В случае, если вы хотите получить только последнюю версию пакета можно использовать команду:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; npm v vue version  
&amp;gt; 2.5.17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если вы захотите получить полный список версий пакета, используйте ту же команду, только во множественном числе:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; npm v vue versions  
&amp;gt; [ '0.0.0',  
  '0.6.0',  
  '0.7.0',  
  ...  
  '2.5.15',  
  '2.5.16',  
  '2.5.17-beta.0',  
  '2.5.17' ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;установка-определенной-версии-пакета&quot;&gt;Установка определенной версии пакета&lt;/h2&gt;

&lt;p&gt;Если необходимо установить определенную версию пакета, которая не является последней, вы можете использовать команду:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i vue@2.5.15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Иногда легче запомнить имя, чем номер, поэтому вы можете использовать dist-теги, перечисленные после выполнения команды &lt;code class=&quot;highlighter-rouge&quot;&gt;npm v&lt;/code&gt;, как показано на выше, вот так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i vue@beta
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Searching for a package&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Иногда вы не можете просто запомнить пакета, который вы использовали в проектах некоторое время назад. В этом случае можно выполнить поиск прямо из терминала, например так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm search gulp debug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm s gulp debug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После выполнения этих команд в терминале будет напечатан список пакетовс оприсанием, указанием авторов и другой информацией.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-01-06-NPM-sovety-i-trjuki/3.png&quot; alt=&quot;&quot; /&gt; Результат поиска&lt;/p&gt;

&lt;h2 id=&quot;удаление-пакетов&quot;&gt;Удаление пакетов&lt;/h2&gt;

&lt;p&gt;Если вы не хотите открывать файл package.json и удалять зависисомтси вручную, можно сделать это с помощью команды:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm uninstall vue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта команда удалит пакет из папки node_modules и из файла package.json. Конечно в данном случае можно использовать команды &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;un&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;, чтобы достичь такого же результата:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm rm vue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если по каким-то причинам вы хотите удалить файлы пакет из папки node_modules, но при этом сохранитьего в чписке зависимостей в файле package.json можете использовать для этого флаг no-save:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm rm vue --no-save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Listing dependencies&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Для того, чтобы посмотреть список всех зависимостей в вашем проекте, используйте комманду:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm ls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта команда выведет в терминале список всех зависимостей из файла package.json, а также &lt;strong&gt;всех их зависимостей&lt;/strong&gt;. если вы хотите получить список только ваших зависисомтей, то воспользуйтесь командой:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm ls --depth=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После выполнения этой команды вы получите что-то подобное:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── jquery@3.3.1  
├── vue@2.5.17  
└── yarn@1.12.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Конечно, вы можете исполььзовать флаг &lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;, если вы хотите получить список всех ваших глобально установленных пакетов:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm ls -g -depth 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;запуск-тестов&quot;&gt;Запуск тестов&lt;/h2&gt;

&lt;p&gt;Тесты можно запускать с помощью комманды &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run tests&lt;/code&gt;, но можно проще - &lt;code class=&quot;highlighter-rouge&quot;&gt;npm test&lt;/code&gt; или еще проще -  &lt;code class=&quot;highlighter-rouge&quot;&gt;npm t&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;показать-доступные-скрипты&quot;&gt;Показать доступные скрипты&lt;/h2&gt;

&lt;p&gt;Иногда мы хотим посмотреть какие скрипты включены в файл package.json. Можно открыть файл package.json, конечно, но можно также запустить команду:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если конфигурация в в файле package.json например выглядит так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;scripts&quot;: {  
  &quot;test&quot;: &quot;jest&quot;,  
  &quot;build&quot;: &quot;gulp build&quot;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;То после выполнения команды &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run&lt;/code&gt; мы получим:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lifecycle scripts included in npm:  
  test  
    jest


available via `npm run-script`:  
  build  
    gulp-build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;установка-пакетов-из-репозитария-github&quot;&gt;Установка пакетов из репозитария GitHub&lt;/h2&gt;

&lt;p&gt;Вы можете также устанавливать пакеты прямо из репозитария GitHub:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i &amp;lt;https://github.com/sindresorhus/gulp-debug&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Или можно опустить доменную часть&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i sindresorhus/gulp-debug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;открытие-github-страницы-пакета&quot;&gt;Открытие Github страницы пакета&lt;/h2&gt;

&lt;p&gt;Можно конечно поискать страницу пакета в Google, а можно запустить следующую команду в терминале:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm repo create-react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Пакет не должен быть установлен во время выполнения этой команды.&lt;/p&gt;

&lt;h2 id=&quot;список-всех-доступных-переменных-среды-npm&quot;&gt;Список всех доступных переменных среды NPM&lt;/h2&gt;

&lt;p&gt;Вы можете увидеть полный список всех переменных NPM, которые доступны:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run env | grep npm_
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После выполнения этой команды в терминале отобразится нечто подобное:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm_config_fetch_retry_maxtimeout=60000  
npm_config_tag_version_prefix=v  
npm_config_strict_ssl=true  
npm_config_sso_type=oauth  
.  
.  
.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это очень полезная вещь, так как зная обо всех переменных которые вам доступны вы можете не только их использовать, но и создавать свои собственные.&lt;/p&gt;

&lt;h2 id=&quot;добавление-собственных-npm-перерменных&quot;&gt;Добавление собственных NPM перерменных&lt;/h2&gt;

&lt;p&gt;Вы можете добавлять свои собственные NPM переменные, добавляя новые ключи в файл package.json. Это богут быть любые ключи, но возможно также хранить все ваши NPM переменные внутри ключа &lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt;, просто в целях лучшей организации. Например так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;config&quot;: {


  &quot;build_folder&quot;:&quot;./dist&quot;


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если после добавления вашей собственной переменоой выполнить команду &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run
env | grep npm_&lt;/code&gt;, вы увидите среди других переменных свою собственную:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm_package_config_build_folder=./dist  
npm_config_fetch_retry_maxtimeout=60000  
npm_config_tag_version_prefix=v  
npm_config_strict_ssl=true  
npm_config_sso_type=oauth  
.  
.  
.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;По умолчанию npm будет присваивать переменным префиксы &lt;code class=&quot;highlighter-rouge&quot;&gt;npm_package&lt;/code&gt; сохраняя таким образом структуру внутри файла package.json.&lt;/p&gt;

&lt;h2 id=&quot;использование-npm-переменной-в-npm-скрипте&quot;&gt;использование NPM переменной в NPM скрипте&lt;/h2&gt;

&lt;p&gt;Предположим, что вы увидели полный список переменных и захотели использовать значения любых из них в вашем скрипте. Вы можете сделать это в вашем файле package.json:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;scripts&quot;: {


  &quot;build&quot;: &quot;gulp build --dist $npm_package_config_build_folder&quot;


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После запуска команды &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt; она будет выполнена как:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp build --dist ./dist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вот и все!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.usejournal.com/npm-tips-and-tricks-c96356fd1b12&quot;&gt;Источник&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="npm" /><category term="nodejs" /><summary type="html">Если вы ежедневно используете NPM в своей работе, то скорее всего вы по достоинству оцените эти подсказки и советы.</summary></entry><entry><title type="html">Uber тестирует сервис предоставления работников во временное пользование</title><link href="https://losthuman.ru/categories/technews/2018/10/19/uber-testiruet-servis-predostavlenija-rabotnikov-vo.html" rel="alternate" type="text/html" title="Uber тестирует сервис предоставления работников во временное пользование" /><published>2018-10-19T00:00:00+05:00</published><updated>2018-10-19T00:00:00+05:00</updated><id>https://losthuman.ru/categories/technews/2018/10/19/Uber-testiruet-servis-predostavlenija-rabotnikov-vo</id><content type="html" xml:base="https://losthuman.ru/categories/technews/2018/10/19/uber-testiruet-servis-predostavlenija-rabotnikov-vo.html">&lt;p&gt;По информации &lt;a href=&quot;https://www.cnet.com/news/uber-tests-uber-works-to-supply-on-demand-temporary-workers/&quot;&gt;cnet.com&lt;/a&gt; компания Uber демонстрирует все признаки еще более глубокого погружения в гик-экономику.&lt;/p&gt;

&lt;p&gt;Компания по сообщениям тестирует расширение своей бизнес-модели, которая в настоящий момент сосредоточена в основном вокруг предоставления услуг краткосрочной аренды автомобилей с водителями, велосипедов и скутеров.  Предполагается, что пилотная программа под названием Uber Works, будет предлагать по требованию временных работников, таких как официанты и охранники, для различных мероприятий.&lt;/p&gt;

&lt;p&gt;Uber работает над этим проектом в течение последних нескольких месяцев в Чикаго и ранее экспериментировал с ним в Лос-Анджелесе. Управляться новый сервис будет по модели уже созданного сервиса UberEats (служба доставки еды).&lt;/p&gt;</content><author><name></name></author><category term="uber" /><summary type="html">По информации cnet.com компания Uber демонстрирует все признаки еще более глубокого погружения в гик-экономику.</summary></entry><entry><title type="html">Swift: Типы и операции. Часть 2</title><link href="https://losthuman.ru/categories/code/2018/10/07/swift-tipy-i-operatsii-chast-2.html" rel="alternate" type="text/html" title="Swift: Типы и операции. Часть 2" /><published>2018-10-07T00:00:00+05:00</published><updated>2018-10-07T00:00:00+05:00</updated><id>https://losthuman.ru/categories/code/2018/10/07/Swift-Tipy-i-operatsii-Chast-2</id><content type="html" xml:base="https://losthuman.ru/categories/code/2018/10/07/swift-tipy-i-operatsii-chast-2.html">&lt;p&gt;Добро пожаловать во вторую часть мини-серии по изучению языка программирования Swift, в которой вы познакомитесь  со строками, преобразованием типов и кортежами. Данный материал является переводом &lt;a href=&quot;https://www.raywenderlich.com/6364-swift-tutorial-part-2-types-and-operations&quot;&gt;tutorial&lt;/a&gt; с сайта &lt;a href=&quot;https://www.raywenderlich.com&quot;&gt;raywenderlich.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Эта часть является продолжением &lt;a href=&quot;https://losthuman.ru/blog/code/2018/10/06/swift-uchebnik-chast-1-vyrazhenija.html&quot;&gt;Swift: выражения, переменные и константы. Часть 1&lt;/a&gt;. Мы рекомендуем Вам начать с первой части, чтобы не пропустить и не потерять.&lt;/p&gt;

&lt;p&gt;Пришло время более подробно поговорить про типы! Формально, тип описывает набор значений и операций, которые могут быть выполнены с ним.&lt;/p&gt;

&lt;p&gt;В этом учебном пособии вы научитесь работаь с различными типами которые есть в Swift. Вы научитесь конвертировать типы один в другой, а также познакомитесь с выводом типа, который сделает вашу жизнь как программиста намного проще.&lt;/p&gt;

&lt;p&gt;В конце вы познакомитесь с кортежами (tuples), которые позволяют создавать собственные множественные значения любого типа.&lt;/p&gt;

&lt;h3 id=&quot;с-чего-начать&quot;&gt;С чего начать&lt;/h3&gt;

&lt;p&gt;Иногда вы будете получать данные в одном формате и нуждаться в том, чтобы конвертировать их в другой формат. Наивно пытаться решить эту задачу следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var integer: Int = 100
var decimal: Double = 12.5
integer = decimal
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Компилятор Swift будет жаловаться, если вы попытаетесь это сделать и выдаст ошибку на третьей строке:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'Cannot assign value of type 'Double' to type 'Int'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Некоторые языки программирования не так строги в отношении типов и будут выполнять такие преобразования автоматически. Опыт показывает, что такое автоматическое преобразование является источником ошибок программного обеспечения, и это часто ухудшает производительность. Swift предотвращает появление в коде присвоения значения одного типа другому, и это позволяет избежать этих проблем.&lt;/p&gt;

&lt;p&gt;Помните, что компьютеры полагаются на программистов, в том, что касается постановки задач и способов их решения. В Swift для исключения возможности появления ошибок включено явное преобразование типов. Если вы хотите чтобы преобразование произощло, вы должны это объявить!&lt;/p&gt;

&lt;p&gt;Вместо простого назначения вам нужно явно указать, что вы хотите преобразовать тип. Вы делаете это так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var integer: Int = 100
var decimal: Double = 12.5
integer = Int(decimal)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Присвоение в третьей строке кода теперь говорит Swift’у недвусмысленно, что вы хотите преобразовать переменную типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; в новый тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Примечание. В этом случае назначение десятичного значения целому числу приводит к потере точности: переменная &lt;code class=&quot;highlighter-rouge&quot;&gt;integer&lt;/code&gt; заканчивается значением &lt;code class=&quot;highlighter-rouge&quot;&gt;12&lt;/code&gt; вместо &lt;code class=&quot;highlighter-rouge&quot;&gt;12,5&lt;/code&gt;. Вот почему важно в данном случае конвертировать типы явным образом. Swift хочет убедиться что вы знаете, что делаете, и что вы понимаете, что таким образом можете потерять данные выполняя преобразование типа.&lt;/p&gt;

&lt;h4 id=&quot;операции-с-разными-типами&quot;&gt;Операции с разными типами&lt;/h4&gt;

&lt;p&gt;Не так давно вы изучили числа и производили операции отдельно с целыми, отдельно с десятичными числами. Но, что если у вас будет целое число и вы захотите умножить его на десятичное?&lt;/p&gt;

&lt;p&gt;Вы может быть думает, что сможете сделать так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let hourlyRate: Double = 19.5
let hoursWorked: Int = 10
let totalCost: Double = hourlyRate * hoursWorked
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если вы попытаетсь это сделать, вы получите ошибку в последней строке:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Binary operator '*' cannot be applied to operands
of type 'Double' and 'Int'`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта шибка появилась потому, что в Swift вы не можете использовать оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; для различных типов данных. Это правило также верно и для других арифметических операторов. На первый взгляд это может показаться удивительным, но Swift делает это прежде всего, чтобы вам помочь.&lt;/p&gt;

&lt;p&gt;Swift заставляет вас быть явным в вопросе, касающемся того, понимаете ли вы что делаете, когда умножатете переменную типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; на переменую типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;, потому, что результатом такой операции может быть только &lt;em&gt;один&lt;/em&gt; тип. Хотите, чтобы результатом умножения был &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; - конвертируйте &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; в &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, до того, как выполнится умножение. Хотите, чтобы результатом операции был &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; - конвертируйте &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; в &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; до выполнения операции умножения.&lt;/p&gt;

&lt;p&gt;В этом примере вы хотите. чтобы результат имел тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;. Вы не хотите, чтобы результатом был &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, потому что в этом случае Swift преобразует константу &lt;code class=&quot;highlighter-rouge&quot;&gt;hourlyRate&lt;/code&gt; в &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, чтобы выполнить умножение, округляя ее до 19 и теряя точность &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Для этого вам нужно сказать Swift, что вы хотите, чтобы он считал константу &lt;code class=&quot;highlighter-rouge&quot;&gt;hoursWorked&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let hourlyRate: Double = 19.5
let hoursWorked: Int = 10
let totalCost: Double = hourlyRate * Double(hoursWorked)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В результате каждый операнд будет иметь тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; когда Swift пермножит их, таким образом константа &lt;code class=&quot;highlighter-rouge&quot;&gt;totalCost&lt;/code&gt; будет иметь тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;вывод-типа&quot;&gt;Вывод типа&lt;/h4&gt;

&lt;p&gt;До настоящего места в этом уроке вы видели, что переменная или константа всегда объявлялись с указанием соответствующего типа, как например в следующем примере:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let integer: Int = 42
let double: Double = 3.14159
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вы можете спросить себя: “Почему я должен всегда писать &lt;code class=&quot;highlighter-rouge&quot;&gt;: Int&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;: Double&lt;/code&gt;, когда в правой части выражения &lt;em&gt;также есть&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;”? Такая избыточность нужна для дополнительной страховки. Вы скоро сможете убедиться, что это можно и не делать.&lt;/p&gt;

&lt;p&gt;Оказывается, компилятор Swift также может это сделать за вас (указать тип переменной ли константы). Вовсе не нужно, чтобы вы все время указывали типы - компилятор может разобраться с типами самостоятельно. Эта работа выполняется благодаря процессу, называемому выводом типа. Не все языки программирования имеют такую способность, но Swift это может, и это ключевой компонент мощи Swift как языка.&lt;/p&gt;

&lt;p&gt;Поэтому вы можете просто удалить тип данных в большинстве мест кода, где вы его видите.&lt;/p&gt;

&lt;p&gt;Например, рассмотрим следующее объявление константы:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let typeInferredInt = 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Иногда полезно проверять предполагаемый тип переменной или константы. Вы можете сделать это в playground, удерживая клавишу &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt; и нажав имя переменной или константы. Xcode отобразит следующее:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-int-1.png&quot;&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-int-1.png&quot; alt=&quot;Inferred Int&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Xcode сообщает вам вывод типа предоставляя вам декларацию о том, что вы
bcgjkmpetnt, если не было вывода типа. В этом случае тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Это же справедливо и для других типов::&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let typeInferredDouble = 3.14159
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Клик по этому параметру показывает следующее:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-double-1.png&quot;&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-inferred-double-1.png&quot; alt=&quot;Inferred Double&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Вывод типа не является чем-то магическим. Swift просто делает то, что без труда делает ваш мозг. Языки программирования, которые не используют вывод типа, часто требуют большей “многословности” при написании кода, потому что вам нужно указывать явно тип каждый раз, когда вы объявляете переменную или константу.&lt;/p&gt;

&lt;p&gt;Иногда вы хотите определить константу или переменную и убедиться, что это определенный тип, хотя то, что вы назначаете ему, является другим типом. Вы видели раньше, как вы можете конвертировать один тип в другой. Например, рассмотрим следующее:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let wantADouble = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь Swift указывает тип &lt;code class=&quot;highlighter-rouge&quot;&gt;wantADouble&lt;/code&gt; как &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;. Но что, если вы хотите вместо этого &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Вы можете сделать следующее:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let actuallyDouble = Double(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это тоже самое, что вы делали раньше для конвертации типов.&lt;/p&gt;

&lt;p&gt;Другая опция может быть не пользуется выводом типа вовсе и работает следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let actuallyDouble: Double = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Есть еще третий способ:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let actuallyDouble = 3 as Double
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь используется нновый оператор, которого вы раньше не видели. &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;, также выполняет конвертацию типа.&lt;/p&gt;

&lt;p&gt;Вообще говоря, символ &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; сам по себе не имеет типа. Это только при использовании в выражении или присваивая этот символ константе или переменной, Swift назначает тип.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Примечание: Буквенные значения не имеют типа. Только при использовании их в
выражениях или присвоения их константе или переменной, для которых Swift требует определить тип.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Также может использоваться литеральное числовое значение, которое не содержит десятичной точки как &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; и как &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;. Вот почему вам разрешено присваивать значение  &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; константе &lt;code class=&quot;highlighter-rouge&quot;&gt;actuallyDouble&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Значения литеральных чисел, которые содержат десятичную точку, не могут быть целыми числами.&lt;/p&gt;

&lt;p&gt;Это означает, что вы могли бы избежать всего этого обсуждения, если бы написали:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`let wantADouble = 3.0`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;строки&quot;&gt;Строки&lt;/h3&gt;

&lt;p&gt;Числа важны для программирования, но они не являются единственным типом данных с которым ужно работать в ваших приложениях. Текст также является чрезвычайно распространенным типом, например, имена людей, их адреса или даже слова книги. Все это - примеры текста, которые может потребоваться для приложения.&lt;/p&gt;

&lt;p&gt;Большинство языков компьютерного программирования хранят текст в типе данных, называемом строкой (&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;). Эта часть урока познакомит вас со строками, сначала дав вам общую информацию о концепции строк, а затем, покажет вам, как их использовать в Swift.&lt;/p&gt;

&lt;h4 id=&quot;как-компьютер-представляет-строки&quot;&gt;Как компьютер представляет строки&lt;/h4&gt;

&lt;p&gt;Компьютеры думают о строках как о наборе отдельных элементов. Весь код, на любом языке программирования, можно сократить до необработанных чисел. Строки также подпадают под данное правило.&lt;/p&gt;

&lt;p&gt;Это может показаться странным. Как символы могут быть числами? В его основе лежит необходимость дать компьютеру  возможность переводить человеческие буквы и цифры в собственный компьютер язык, и он делает это, назначая каждому элементу другое число. Эта система образует двухстороннее сопоставление от символа к числу, и наоборот.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-unicode-comic.png&quot;&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-unicode-comic-650x406.png&quot; alt=&quot;Unicode comic&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Когда вы нажимаете клавишу на клавиатуре, вы на самом деле передаете номер определенного элемента (буквы) в компьютер. Ваш текстовый процессор (приложение) преобразует это число в изображение элемента (буквы) и, наконец, представляет вам результат преобразования на экране монитора.&lt;/p&gt;

&lt;h3 id=&quot;unicode&quot;&gt;Unicode&lt;/h3&gt;

&lt;p&gt;В сущности компьютер абстрактно свободен в выборе любого символьного набора. Если компьютер хочет, чтобы буква а равнялась числу 10, тогда это так и может быть. Но когда компьютеры начинают разговаривать друг с другом, им необходимо использовать общий набор символов. Если на двух компьютерах используются разные наборы символов, тогда, когда один компьютер передал строку другому, получится в конечном итоге что строки содержат разные символы.&lt;/p&gt;

&lt;p&gt;Было несколько популярных стандартов, но самым современным стандартом является Unicode. Он определяет отображение набора символов, которое используют почти все компьютеры сегодня.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Примечание: Вы можете прочитать больше об Unicode на &lt;a href=&quot;http://unicode.org&quot;&gt;официальном сайте&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Рассмотрим слово cafe. Стандарт Unicode говорит нам, что буквы этого слова должны быть закодированы цифрами следующим образом:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/cafe-1.png&quot; alt=&quot;cafe&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Число, связанное с каждым символом, называется кодовой точкой. Итак, в
пример выше, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; использует кодовую точку 99, &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; использует кодовую точку 97 и так далее.&lt;/p&gt;

&lt;p&gt;Конечно, Unicode предназначен не только для простых латинских символов, используемых в английском языке, например, c, a, f и e. Он также позволяет вам отображать символы из языков во всем мире. Слово кафе происходит от французского, в котором написано как cafe. Unicode отображает эти символы так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/cafe_with_accent.png&quot; alt=&quot;cafe_with_accent&quot; /&gt;&lt;/p&gt;

&lt;p&gt;И вот пример использования китайских иероглифов (это, согласно Google переводчику, означает “Computer Programming”):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/computer_programming_chinese-650x164.png&quot; alt=&quot;computer_programming_chinese&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Вы, наверное, слышали об эмодзи, которые представляют собой небольшие картинки, которые вы можете использовать в вашем тексте. Эти картинки, по сути, являются просто обычными буквами, также отображаемыми Unicode. Например:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/poo_face.png&quot; alt=&quot;poo_face&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Это всего два символа. Кодовые точки для них очень большие числа, но каждая из них по-прежнему остается только одной кодовой точкой. Компьютер считает они ничем не отличаются от любых других двух символов.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Примечание: слово «emoji» происходит от японского: «e» означает изображение, а «moji» означает буквы.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;строки-в-swift&quot;&gt;Строки в Swift&lt;/h3&gt;

&lt;p&gt;Swift, как и любой хороший язык программирования, может работать непосредственно и с буквами, и со строками. Он делает это через типы данных &lt;code class=&quot;highlighter-rouge&quot;&gt;Character&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, соответственно. В этом разделе вы узнаете об этих типах данных и о том, как работать с ними.&lt;/p&gt;

&lt;h4 id=&quot;characters-and-strings&quot;&gt;Characters and Strings&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Character&lt;/code&gt; это тип данных, экземпляр которого может хранить одну букву (один символ). Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let characterA: Character = &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Таким способом хранится буква &lt;code class=&quot;highlighter-rouge&quot;&gt;а&lt;/code&gt;. Точно также мохно хранить любой символ, даже эмодзи:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let characterDog: Character = &quot;🐶&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но этот тип данных разработан для хранения только одного символа. А вот тип &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; может хранить несколько символов. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let stringDog: String = &quot;Dog&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Правая сторона этого выражения представляет собой то, что известно под названием строковый литерал. Это синтаксис Swift для представления строк.&lt;/p&gt;

&lt;p&gt;Конечно, вывод типа применяется по отношению к строкам также, как к числам. Если вы удалите тип из объявления константы &lt;code class=&quot;highlighter-rouge&quot;&gt;stringDog&lt;/code&gt; тогда Swift справедливо назначит этой константе тип &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let stringDog = &quot;Dog&quot; // Inferred to be of type String
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Примечание: В Swift нет такого понятия, как символьный литерал. Символ представляется строкой с длинной равной единице. Однако Swift указывает тип любой строки литералом &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, поэтому, если вы хотите вместо этого получить тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Character&lt;/code&gt;, вы должны явно назначить этот тип.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;конкатенация-строк&quot;&gt;Конкатенация строк&lt;/h4&gt;

&lt;p&gt;Вы можете делать гораздо больше, чем создавать простые строки. Иногда вам нужно
манипулировать строкой, и один из общих способ сделать это - объединить ее с другими строками.&lt;/p&gt;

&lt;p&gt;В Swift это делается довольно просто: с помощью оператора сложения. Так же, как вы можете сложить числа, вы можете сложить строки:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var message = &quot;Hello&quot; + &quot; my name is &quot;
let name = &quot;Lorenzo&quot;
message += name // &quot;Hello my name is Lorenzo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вам нужно объявить &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt; как переменную, а не константу, потому что вы хотите изменить ее. Вы можете добавить строковые литералы сразу вместе, как в первой строке, но также вы можете добавить строковые переменные или константы так, как это сделано в последней строке.&lt;/p&gt;

&lt;p&gt;Также возможно добавить символы в строку. Однако строгая типизация Swift означает, что типы должны быть явными, так же, точно так же как это было показано на примере чисел.&lt;/p&gt;

&lt;p&gt;Чтобы добавить символ в строку, можно сделать следующее:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let exclamationMark: Character = &quot;!&quot;
message += String(exclamationMark) // &quot;Hello my name is Lorenzo!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;С помощью этого кода вы явно преобразуете &lt;code class=&quot;highlighter-rouge&quot;&gt;Character&lt;/code&gt; в строку &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; до того, как добавите его в &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;интерполяция-строк&quot;&gt;Интерполяция строк&lt;/h4&gt;

&lt;p&gt;Вы также можете создать строку, используя интерполяцию, которая является специальным cинтаксисом Swift и позволяет создавать строку таким способом, который легко читать:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = &quot;Lorenzo&quot;
let messageInOne = &quot;Hello my name is \(name)!&quot; // &quot;Hello my name is Lorenzo!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Такой код читается гораздо легче, чем пример из предыдущего раздела.
Это расширение синтаксиса строкового литерала, посредством которого вы заменяете определенные части строки другими значениями.&lt;/p&gt;

&lt;p&gt;Такой синтаксис работает точно так же, как построение строк из других типов, таких как числа:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let oneThird = 1.0 / 3.0
let oneThirdLongString = &quot;One third is \(oneThird) as a decimal.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном примере вы добавляете в строку константу &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; способом интерполяции. В результатае последняя строка кода - константа &lt;code class=&quot;highlighter-rouge&quot;&gt;oneThirdLongString&lt;/code&gt; будет содержать следующее:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;One third is 0.3333333333333333 as a decimal.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Разумеется, на самом деле длинна &lt;code class=&quot;highlighter-rouge&quot;&gt;oneThird&lt;/code&gt; практически бесконечна, потому что это повторяющееся десятичное число. Строчная интерполяция с помощью &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; не дает возможности контролировать точность получаемой строки.&lt;/p&gt;

&lt;p&gt;Это следствие использования интерполяции строк - просто для использования, но не дает возможности настраивать вывод. Имейте это ввиду.&lt;/p&gt;

&lt;h4 id=&quot;многострочные-строки&quot;&gt;Многострочные строки&lt;/h4&gt;

&lt;p&gt;У Swift есть удобный способ представления многострочных строк. Это может быть весьма полезным, когда вам нужно поместить очень длинную строку в свой код.&lt;/p&gt;

&lt;p&gt;Делается это так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let bigString = &quot;&quot;&quot;
    Вы можете создавать строки  
    которые имеют несколько  
    строк  
    делая это
    таким способом.
    &quot;&quot;&quot;
print(bigString)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Три двойные кавычки означают, что это многострочная строка. Первая и последняя строки кода не становятся частью строки. Это делает его более гибким.&lt;/p&gt;

&lt;p&gt;В приведенном выше примере будет напечатано следующее:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Вы можете создавать строки  
которые имеют несколько  
строк  
делая это
таким способом.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;кортежи-tuples&quot;&gt;Кортежи (Tuples)&lt;/h3&gt;

&lt;p&gt;Иногда данные формируются парами или тройками. Примером этого является пара (x, y) в двумерной сетке. Аналогично, набор координат в трехмерной сетке состоит из значения x, y-значения и z-значения.&lt;/p&gt;

&lt;p&gt;В Swift вы можете представлять такие связанные данные очень простым способом через использование кортежа.&lt;/p&gt;

&lt;p&gt;Кортеж - это тип, который представляет данные, состоящие из более чем одного значения любого типа. Вы можете иметь столько значений в кортеже, сколько захотите. Например, вы может определять пару двумерных координат, где каждое значение оси представляет собой целое число, вот так:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinates: (Int, Int) = (2, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тип &lt;code class=&quot;highlighter-rouge&quot;&gt;coordinates&lt;/code&gt; - это кортеж, содержащий два значения &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;. Типы значений внутри кортежа, в этом случае &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, разделяются запятыми окруженный круглыми скобками. Код для создания кортежа - тое же, с каждым значением, разделенным запятыми и окруженным скобками.&lt;/p&gt;

&lt;p&gt;Вывод типа может также определять типы кортежей:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinatesInferred = (2, 3) // вывод типа (Int, Int)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Таким же образом можно создать кортеж, состоящий из знчений &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinatesDoubles = (2.1, 3.5) // Вывод типа (Double, Double)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Или вы можете включать в кортеж различные типы:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinatesMixed = (2.1, 3) // Вывод типа (Double, Int)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А вот как происходит доступ к данным внутри кортежа:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinates = (2, 3)
let x1 = coordinates.0
let y1 = coordinates.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вы можете получить каждый элемент в кортеже по его индексу в кортеже, начиная с нуля. Итак, в этом примере &lt;code class=&quot;highlighter-rouge&quot;&gt;x1&lt;/code&gt; будет равен &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;, а &lt;code class=&quot;highlighter-rouge&quot;&gt;y1&lt;/code&gt; будет равен &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Примечание: Начало отстчета с нуля, это обычная практика в программировании и называется нулевой индексацией.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;В предыдущем примере может быть не сразу очевидно, что первое значение в индексе &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; - это координата x, а второе значение - по индексу &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, является y-координатой. Это еще одна демонстрация того, почему важно всегда называть переменные таким образом, чтобы избежать путаницы.&lt;/p&gt;

&lt;p&gt;К счастью, Swift позволяет вам называть отдельные части кортежа, и вы можете явно указать на то, что представляет каждая часть. Например:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinatesNamed = (x: 2, y: 3) 
// Вывод типа (x: Int, y: Int)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В коде аннотированы значения &lt;code class=&quot;highlighter-rouge&quot;&gt;coordinatesNamed&lt;/code&gt;, содержащий метку для каждой части кортежа. Затем, когда вам нужно получить доступ к каждой части кортежа, вы сможете получить к ней доступ через имя соответствующего элемента кортежа:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let x2 = coordinatesNamed.x
let y2 = coordinatesNamed.y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это гораздо понятнее. Полезно именовать компоненты ваших кортежей.&lt;/p&gt;

&lt;p&gt;Если вы хотите получить доступ к нескольким частям кортежа одновременно, как в примере выше, вы также можете использовать сокращенный синтаксис, упрощающий доступ к элементам кортежа:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinates3D = (x: 2, y: 3, z: 1)
let (x3, y3, z3) = coordinates3D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Объявлене трех новых констант: &lt;code class=&quot;highlighter-rouge&quot;&gt;x3&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y3&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;z3&lt;/code&gt; и присваивание каждую часть
кортежа соответствующим константам. Код эквивалентен следующему:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coordinates3D = (x: 2, y: 3, z: 1)
let x3 = coordinates3D.x
let y3 = coordinates3D.y
let z3 = coordinates3D.z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если вы хотите игнорировать определенный элемент кортежа, вы можете заменить соответствующую часть декларации нижним дефисом. Например, если вы выполняли 2D-расчет и хотели игнорировать z-координату &lt;code class=&quot;highlighter-rouge&quot;&gt;coord3D&lt;/code&gt;, то вы должны написать следующее:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let (x4, y4, _) = coordinates3D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта строка кода объявляет только &lt;code class=&quot;highlighter-rouge&quot;&gt;x4&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;y4&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; является особым знаком и означает, что вы сейчас игнорируете эту часть.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Примечание: Вы увидите, что вы можете использовать символ нижнего дефиса - также называемый оператором подстановочного знака - во всем Swift, чтобы игнорировать значение.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;числовые-типы&quot;&gt;Числовые типы&lt;/h3&gt;

&lt;p&gt;Вы используете &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; для представления целых чисел. &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; представлен 64-битным на большинстве современных аппаратных средств и 32-битным на устаревших или имеющих ограниченные ресурсы. На самом деле Swift предоставляет гораздо больше числовых типов, которые используют разные объемы памяти для хранения значений. Для целых чисел вы можете использовать явное объявление типов &lt;code class=&quot;highlighter-rouge&quot;&gt;Int8&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;Int16&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Int32&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;Int64&lt;/code&gt;. Эти типы занимают 1, 2, 4 и 8 байтов памяти, соответственно. Каждый из этих типов использует 1 бит для хранения одного знака.&lt;/p&gt;

&lt;p&gt;Если вы имеете дело только с неотрицательными значениями, существует набор явных
беззнаковые типов, которые вы можете использовать. К ним относятся &lt;code class=&quot;highlighter-rouge&quot;&gt;UInt8&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UInt16&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UInt32&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;UInt64&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ниже приведен краткий обзор различных целых типов и размеров памяти, необходимой для их хранения. В большинстве случаев вы захотите использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;. Другие числовые типы как правило становятся полезными в приложении, если ваш код взаимодействует с другим программным обеспечением, которое использует один из этих более точных типов, или если вам нужно оптимизировать для хранения размер данных.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/int_sizes-650x274.png&quot; alt=&quot;int_sizes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Вы использовали &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; для представления дробных чисел. Swift предлагает &lt;code class=&quot;highlighter-rouge&quot;&gt;Float&lt;/code&gt;, который имеет меньше разрядов и точность чем &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;, но требует вдвое меньше места для хранения. Современное аппаратное обеспечение как правило  оптимизировано для &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;, поэтому &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; это тот тип, который следует использовать, если, вы хотите получить максимальную точность десятичного числа.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/float_sizes-650x91.png&quot; alt=&quot;float_sizes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В большинстве случаев вы будете использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt; для представления чисел, но время от времени, вы можете столкнуться с другими типами. Вы уже знаете как с ними бороться. Например, предположим, что необходимо сложить &lt;code class=&quot;highlighter-rouge&quot;&gt;INT16&lt;/code&gt; с &lt;code class=&quot;highlighter-rouge&quot;&gt;uint8&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;int32&lt;/code&gt;. Вы можете сделать это следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a: Int16 = 12
let b: UInt8 = 255
let c: Int32 = -100000

let answer = Int(a) + Int(b) + Int(c) // Answer is an Int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;взгляд-за-кулисы-протоколы&quot;&gt;Взгляд за кулисы: протоколы&lt;/h3&gt;

&lt;p&gt;Несмотря на то, что существует десяток различных числовых типов, их довольно легко понять и использовать. Это потому, что все они поддерживают примерно одни и те же операции. Другими словами, если вы знаете, как использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, использовать любой другой из числовых типов будет очень просто.&lt;/p&gt;

&lt;p&gt;Одной из поистине замечательных особенностей Swift является то, как он формализует идею общности типов, используя то, что называют протоколами. Изучая протокол, вы мгновенно поймете, как целое семейство типов, которые используют этот протокол работают.&lt;/p&gt;

&lt;p&gt;В случае целых чисел, этот принцип представлен на диаграмме:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-integer-protocols.png&quot;&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2018/07/swift-tutorial-part-2-integer-protocols-650x459.png&quot; alt=&quot;Integer Protocols&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Стрелки указывают на соответствие (иногда называемое &lt;em&gt;адоптация&lt;/em&gt;) протоколу. Не смотря на то, что этот график не показывает все протоколы, которым соответствуют  целочисленные типы, это дает вам представление о том, как все организовано.&lt;/p&gt;

&lt;p&gt;Swift является первым языком, созданным на основе протоколов. Когда вы начнете понимать протоколы, которым соответствую типы, вы можете начать использовать эту систему способами невозможными в других языках.&lt;/p&gt;

&lt;h3 id=&quot;что-дальше&quot;&gt;Что дальше?&lt;/h3&gt;

&lt;p&gt;Вы можете загрузить финальный &lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2018/09/Swift-Tutorial-Part-2.zip&quot;&gt;файл playground&lt;/a&gt;. Там же  вы найдете мини-упражнения для выполнения. Если вы застряли или вам нужна помощь, не стесняйтесь воспользоваться сопутствующими решениями.&lt;/p&gt;

&lt;p&gt;В этом уроке вы узнали, что типы являются фундаментальной частью программирования. Это то, что позволяет правильно хранить данные. Кроме этого вы познакомились со строками и кортежами, а также кучей числовых типов.&lt;/p&gt;

&lt;p&gt;В следующей части вы узнаете о Булевой логике и простом управлении потоком передачи данных.&lt;/p&gt;</content><author><name></name></author><category term="swift" /><category term="programming" /><summary type="html">Добро пожаловать во вторую часть мини-серии по изучению языка программирования Swift, в которой вы познакомитесь со строками, преобразованием типов и кортежами. Данный материал является переводом tutorial с сайта raywenderlich.com.</summary></entry><entry><title type="html">Как много денег потратил генеральный директор Apple Тим Кук в попытках предотвратить президентство Дональда Трампа</title><link href="https://losthuman.ru/categories/technews/2018/10/06/kak-mnogo-deneg-potratil-generalnyj-direktor.html" rel="alternate" type="text/html" title="Как много денег потратил генеральный директор Apple Тим Кук в попытках предотвратить президентство Дональда Трампа" /><published>2018-10-06T00:00:00+05:00</published><updated>2018-10-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/technews/2018/10/06/Kak-mnogo-deneg-potratil-generalnyj-direktor</id><content type="html" xml:base="https://losthuman.ru/categories/technews/2018/10/06/kak-mnogo-deneg-potratil-generalnyj-direktor.html">&lt;p&gt;По &lt;a href=&quot;https://www.businessinsider.com/how-much-apple-ceo-tim-cook-donated-to-hillary-clinton-campaign-to-stop-donald-trump-2018-10&quot;&gt;сообщению&lt;/a&gt; портала &lt;strong&gt;Businessinsider&lt;/strong&gt; cортудники Apple совсем не хотели, чтобы президентом США стал Дональд Трамп, ну, как минимум не хотел Тим Кук.&lt;/p&gt;

&lt;p&gt;Подробный &lt;a href=&quot;https://gov predict.com/blog/contributions-by-apple-employees/&quot;&gt;анализ политических пожертвований, сделанных сотрудниками Apple&lt;/a&gt;
ясно показывает, что Хиллари Клинтон была крупным бенефициаром пожертвований от компании из Купертино.&lt;/p&gt;

&lt;p&gt;В общей сложности она получила 1,8 млн. долларов от сотрудников Apple. Главным пожертвователем был Тим Кук, он направил в избирательный фонд Хилари Клинтон самую крупну сумму из всех персональных пожертвований купертиновцев - 236 100 долларов.&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;und&quot; dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://t.co/hrCAaTz96Y&quot;&gt;pic.twitter.com/hrCAaTz96Y&lt;/a&gt;&lt;/p&gt;&amp;mdash; Joshua Cohen (@jcohen570) &lt;a href=&quot;https://twitter.com/jcohen570/status/768609363086815232?ref_src=twsrc%5Etfw&quot;&gt;August 25, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;В противоположность этому факту персонал Apple внес только 6 786 долларов в фонд избирательной кампании Трампа в 2016 году. Пожертвования Apple Клинтон также затмили 610 805,00 долларов сделанные работниками Amazon.&lt;/p&gt;

&lt;p&gt;Пожертвование Тима Кука в избирательный фонд Клинтон контрастирует с его довольно скромными политическими взносами в прошлом, которые были парктически равномерно распределены между демократами и республиканцами.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-06-Kak-mnogo-deneg-potratil-generalnyj-direktor/1.png&quot; alt=&quot;Пожертвования генерального директора Applе&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnbc.com/2016/08/24/apples-tim-cook-has-spread-his-political-money-to-both-sides-of-the-aisle.html&quot;&gt;По информации CNBC&lt;/a&gt;, Кук лично внес 10 800,00 долларов республиканским кандидатом на их кампании начиная с 2008 года, и и за тот же период он отдал 10 400,00 долларов кандидатам от демокартической партии США.&lt;/p&gt;

&lt;p&gt;Кук также рассматривался как потенциальный кандидат на пост вице-президента США, в случае победы Клинтон  на президентских выборах 2016 года. Эта информация просочилась в прессу после утечек конфиденциальной информации, которая была опубликована Wikileaks.&lt;/p&gt;

&lt;p&gt;С тех пор как Трамп был избран, Кук занял прагматичный подход к отношениям с
президентом. Они встречались несколько раз, включая проведение
последних переговоров по поводу торговой войны с Китаем.&lt;/p&gt;

&lt;p&gt;В целом же персонал Apple пожертвовал более чем 1,3 млн. долларов в избирательные фонды демократов в 2016 году, и всего лишь около 232 тысяч долларов на компании республиканской партии США.&lt;/p&gt;</content><author><name></name></author><category term="apple" /><summary type="html">По сообщению портала Businessinsider cортудники Apple совсем не хотели, чтобы президентом США стал Дональд Трамп, ну, как минимум не хотел Тим Кук.</summary></entry><entry><title type="html">Facebook и Apple подтвердили, что они были целью хакерских атак Supermicro</title><link href="https://losthuman.ru/categories/technews/2018/10/06/facebook-apple-podtverdili-chto-oni-byli.html" rel="alternate" type="text/html" title="Facebook и Apple подтвердили, что они были целью хакерских атак Supermicro" /><published>2018-10-06T00:00:00+05:00</published><updated>2018-10-06T00:00:00+05:00</updated><id>https://losthuman.ru/categories/technews/2018/10/06/Facebook-Apple-podtverdili-chto-oni-byli</id><content type="html" xml:base="https://losthuman.ru/categories/technews/2018/10/06/facebook-apple-podtverdili-chto-oni-byli.html">&lt;p&gt;Интрига нарастает. В &lt;a href=&quot;https://mashable.com/article/chinese-malware-server-attack-bloomberg-facebook-apple/#uHMWx3YlEGqV&quot;&gt;материале&lt;/a&gt; &lt;strong&gt;Mashable&lt;/strong&gt; сообщается, что после &lt;a href=&quot;https://www.bloomberg.com/news/features/2018-10-04/the-big-hack-how-Китай-используется-в-маленьких-чип-корни-Америка-с-топ-компаний&quot;&gt;доклада Bloomberg&lt;/a&gt; о китайской атаке через цепочку поставок комплектующих производителя серверов Supermicro в крупные американские компании, включая Apple и Amazon, начала появляться реакция  от некоторых участников этой драмы. Две из этих крупных американских компаний, подтвердили, что пострадали от вредоносной атаки: это Apple и Facebook.&lt;/p&gt;

&lt;p&gt;В отличие от Amazon и отрицавшей в первоначальном заявлении Apple, теперь
Facebook и та же Apple подтвердили, что нашли вредоносное ПО всерверах Supermicro.&lt;/p&gt;

&lt;p&gt;Facebook сообщил, что компания была осведомлена о серверах со скомпрометированной прошивкой в 2015 году на “ограниченноь количестве оборудования Supermicro”, которое были использованыо только “для
целей тестирования и его (оборудования) импользование было ограничено нашими лабораториями”. Другими словами, Facebook говорит, что атака не затронула пользователей. После такого сообщения невольно в памяти всплывает дело компании
с нарушением персональных данных, которое затронуло &lt;a href=&quot;https://mashable.com/article/facebook-50-million-accounts-hacked/&quot;&gt;50 миллионов человек&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Apple заявила, что обнаружила вредоносное ПО на одном сервере в 2016 году. Это не противоречит отрицанию аппаратной атаки. На самом деле, это укрепляет его, потому что Apple указывает на вредоносное ПО в качестве причины он отказа сотрудничества с  Supermicro в качестве поставщика в 
&lt;a href=&quot;https://www.apple.com/newsroom/2018/10/what-businessweek-got-wrong-about-apple/&quot;&gt;официальном заявлении&lt;/a&gt;, а не наличие вредоносных микрочипов в
серверах.&lt;/p&gt;

&lt;p&gt;Это подтверждение от обоих компаний требует дополнительного анализа и осмысления, однако однозначно то, что китайские хакеры предпринимали попытки незаконного доступа к данным американских компаний и их пользователей. Это то, что китайское правительство отрицало, в ответ на запрос агенства Bloomberg. Что остается неясным, так это размер атаки, а также то по каким причинам Amazon и Apple отрицают наличие аппаратной атаки со стороны китайцев.&lt;/p&gt;</content><author><name></name></author><category term="security" /><category term="apple" /><category term="google" /><category term="amazon" /><summary type="html">Интрига нарастает. В материале Mashable сообщается, что после доклада Bloomberg о китайской атаке через цепочку поставок комплектующих производителя серверов Supermicro в крупные американские компании, включая Apple и Amazon, начала появляться реакция от некоторых участников этой драмы. Две из этих крупных американских компаний, подтвердили, что пострадали от вредоносной атаки: это Apple и Facebook.</summary></entry></feed>